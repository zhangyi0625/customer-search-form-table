import node_fs, { chmodSync, promises } from "node:fs";
import node_path, { basename, dirname, extname, isAbsolute, join } from "node:path";
import { glob } from "tinyglobby";
import { createRequire } from "node:module";
import picocolors from "../compiled/picocolors/index.js";
import { logger } from "../compiled/rslog/index.js";
import node_fs_promises from "node:fs/promises";
import { createRequire as external_module_createRequire } from "module";
import { EventEmitter } from "events";
import * as __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__ from "@rsbuild/core";
const DEFAULT_CONFIG_NAME = 'rslib.config';
const DEFAULT_CONFIG_EXTENSIONS = [
    '.js',
    '.ts',
    '.mjs',
    '.mts',
    '.cjs',
    '.cts'
];
const SWC_HELPERS = '@swc/helpers';
const SHEBANG_PREFIX = '#!';
const SHEBANG_REGEX = /#!.*[\s\n\r]*$/;
const REACT_DIRECTIVE_REGEX = /^['"]use (client|server)['"](;?)[\s\n\r]*$/;
const DTS_EXTENSIONS = [
    'd.ts',
    'd.mts',
    'd.cts'
];
const JS_EXTENSIONS = [
    'js',
    'mjs',
    'jsx',
    '(?<!\\.d\\.)ts',
    '(?<!\\.d\\.)mts',
    '(?<!\\.d\\.)cts',
    'tsx',
    'cjs',
    'cjsx',
    'mjsx',
    'mtsx',
    'ctsx'
];
const CSS_EXTENSIONS = [
    'css',
    'sass',
    'scss',
    'less',
    'styl',
    'stylus'
];
const JS_EXTENSIONS_PATTERN = new RegExp(`\\.(${JS_EXTENSIONS.join('|')})$`);
const CSS_EXTENSIONS_PATTERN = new RegExp(`\\.(${CSS_EXTENSIONS.join('|')})$`);
const DTS_EXTENSIONS_PATTERN = new RegExp(`\\.(${DTS_EXTENSIONS.join('|')})$`);
function getUndoPath(filename, outputPathArg, enforceRelative) {
    let depth = -1;
    let append = '';
    let outputPath = outputPathArg.replace(/[\\/]$/, '');
    for (const part of filename.split(/[/\\]+/))if ('..' === part) if (depth > -1) depth--;
    else {
        const i = outputPath.lastIndexOf('/');
        const j = outputPath.lastIndexOf('\\');
        const pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);
        if (pos < 0) return `${outputPath}/`;
        append = `${outputPath.slice(pos + 1)}/${append}`;
        outputPath = outputPath.slice(0, pos);
    }
    else if ('.' !== part) depth++;
    return depth > 0 ? `${'../'.repeat(depth)}${append}` : enforceRelative ? `./${append}` : append;
}
function isCssFile(filepath) {
    return CSS_EXTENSIONS_PATTERN.test(filepath);
}
const CSS_MODULE_REG = /\.module\.\w+$/i;
const PATH_QUERY_FRAGMENT_REGEXP = /^((?:\u200b.|[^?#\u200b])*)(\?(?:\u200b.|[^#\u200b])*)?(#.*)?$/;
function parsePathQueryFragment(str) {
    const match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);
    return {
        path: match?.[1]?.replace(/\u200b(.)/g, '$1') || '',
        query: match?.[2] ? match[2].replace(/\u200b(.)/g, '$1') : '',
        fragment: match?.[3] || ''
    };
}
function isCssModulesFile(filepath, auto) {
    const filename = node_path.basename(filepath);
    if (true === auto) return CSS_MODULE_REG.test(filename);
    if (auto instanceof RegExp) return auto.test(filepath);
    if ('function' == typeof auto) {
        const { path, query, fragment } = parsePathQueryFragment(filepath);
        return auto(path, query, fragment);
    }
    return false;
}
function isCssGlobalFile(filepath, auto) {
    const isCss = isCssFile(filepath);
    if (!isCss) return false;
    const isCssModules = isCssModulesFile(filepath, auto);
    return !isCssModules;
}
const LibSvgrPatchPlugin_pluginName = 'LIB_SVGR_PATCH_PLUGIN';
const PUBLIC_PATH_PLACEHOLDER = '__RSLIB_SVGR_AUTO_PUBLIC_PATH__';
class LibSvgrPatchPlugin {
    name = LibSvgrPatchPlugin_pluginName;
    apply(compiler) {
        compiler.hooks.make.tap(this.name, (compilation)=>{
            compilation.hooks.processAssets.tap(this.name, (assets)=>{
                const isEsm = Boolean(compilation.options.output.module);
                const chunkAsset = Object.keys(assets).filter((name)=>/js$/.test(name));
                for (const name of chunkAsset)compilation.updateAsset(name, (old)=>{
                    const oldSource = old.source().toString();
                    const newSource = new __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.sources.ReplaceSource(old);
                    const pattern = new RegExp(`\\(?['"]${PUBLIC_PATH_PLACEHOLDER}(.*)['"]\\)?`, 'g');
                    const matches = [
                        ...oldSource.matchAll(pattern)
                    ];
                    const len = matches.length;
                    if (0 === len) return old;
                    const undoPath = getUndoPath(name, compilation.outputOptions.path, true);
                    for(let i = 0; i < len; i++){
                        const match = matches[i];
                        const filename = match[1];
                        const requirePath = `${undoPath}${filename}`;
                        let replaced = '';
                        replaced = isEsm ? `__rslib_svgr_url__${i}__` : `require("${requirePath}")`;
                        newSource.replace(match.index, match.index + match[0].length - 1, replaced);
                        if (isEsm) newSource.insert(0, `import __rslib_svgr_url__${i}__ from "${requirePath}";\n`);
                    }
                    return newSource;
                });
            });
        });
    }
}
const PLUGIN_NAME = 'rsbuild:lib-asset';
const RSBUILD_SVGR_PLUGIN_NAME = 'rsbuild:svgr';
const pluginLibAsset = ({ bundle })=>({
        name: PLUGIN_NAME,
        pre: [
            RSBUILD_SVGR_PLUGIN_NAME
        ],
        setup (api) {
            api.modifyBundlerChain((config, { CHAIN_ID })=>{
                const svgAssetRule = config.module.rules.get(CHAIN_ID.RULE.SVG).oneOfs.get(CHAIN_ID.ONE_OF.SVG_ASSET);
                const originalTypeOptions = svgAssetRule.get('type');
                const originalParserOptions = svgAssetRule.get('parser');
                const originalGeneratorOptions = svgAssetRule.get('generator');
                const isUserSetPublicPath = 'auto' !== config.output.get('publicPath');
                const generatorOptions = isUserSetPublicPath ? originalGeneratorOptions : {
                    ...originalGeneratorOptions,
                    importMode: 'preserve'
                };
                const rule = config.module.rule(CHAIN_ID.RULE.SVG);
                rule.oneOf(CHAIN_ID.ONE_OF.SVG_ASSET).generator(generatorOptions).issuer({
                    not: CSS_EXTENSIONS_PATTERN
                });
                rule.oneOf(`${CHAIN_ID.ONE_OF.SVG_ASSET}-for-css`).type(originalTypeOptions).parser(originalParserOptions).generator(originalGeneratorOptions).issuer(CSS_EXTENSIONS_PATTERN);
                const ruleIds = [
                    CHAIN_ID.RULE.FONT,
                    CHAIN_ID.RULE.MEDIA,
                    CHAIN_ID.RULE.IMAGE,
                    CHAIN_ID.RULE.ADDITIONAL_ASSETS
                ];
                for (const ruleId of ruleIds){
                    const oneOfId = `${ruleId}-asset`;
                    const assetRule = config.module.rules.get(ruleId);
                    if (!assetRule) continue;
                    const assetRuleOneOf = assetRule.oneOfs.get(oneOfId);
                    const originalTypeOptions = assetRuleOneOf.get('type');
                    const originalParserOptions = assetRuleOneOf.get('parser');
                    const originalGeneratorOptions = assetRuleOneOf.get('generator');
                    const generatorOptions = isUserSetPublicPath ? originalGeneratorOptions : {
                        ...originalGeneratorOptions,
                        importMode: 'preserve'
                    };
                    const rule = config.module.rule(ruleId);
                    rule.oneOf(oneOfId).generator(generatorOptions).issuer({
                        not: CSS_EXTENSIONS_PATTERN
                    });
                    rule.oneOf(`${oneOfId}-for-css`).type(originalTypeOptions).parser(originalParserOptions).generator(originalGeneratorOptions).issuer(CSS_EXTENSIONS_PATTERN);
                }
                const isUsingSvgr = config.module.rule(CHAIN_ID.RULE.SVG).oneOf(CHAIN_ID.RULE.SVG).uses.has(CHAIN_ID.USE.SVGR);
                const isUsingSvgrUrlLoader = config.module.rule(CHAIN_ID.RULE.SVG).oneOf(CHAIN_ID.ONE_OF.SVG).uses.has(CHAIN_ID.USE.URL);
                if (isUsingSvgr && isUsingSvgrUrlLoader) {
                    const urlLoaderRule = config.module.rule(CHAIN_ID.RULE.SVG).oneOf(CHAIN_ID.ONE_OF.SVG).use(CHAIN_ID.USE.URL);
                    const originalOptions = urlLoaderRule.get('options');
                    urlLoaderRule.options({
                        ...originalOptions,
                        publicPath: (url)=>`${PUBLIC_PATH_PLACEHOLDER}${url}`
                    });
                    config.plugin(LibSvgrPatchPlugin.name).use(LibSvgrPatchPlugin, []);
                }
                if (isUsingSvgr) if (bundle) {
                    const rule = config.module.rule(CHAIN_ID.RULE.SVG).oneOf(CHAIN_ID.ONE_OF.SVG_URL);
                    const originalGeneratorOptions = rule.get('generator');
                    const generatorOptions = isUserSetPublicPath ? originalGeneratorOptions : {
                        ...originalGeneratorOptions,
                        importMode: 'preserve'
                    };
                    rule.generator(generatorOptions);
                } else {
                    const rule = config.module.rule(CHAIN_ID.RULE.SVG).oneOf(CHAIN_ID.ONE_OF.SVG);
                    rule.issuer({
                        not: CSS_EXTENSIONS_PATTERN
                    });
                }
                if (bundle) config.plugins.get(CHAIN_ID.PLUGIN.MINI_CSS_EXTRACT)?.tap((options)=>[
                        {
                            ...options[0],
                            enforceRelative: true
                        }
                    ]);
            });
        }
    });
const composeAssetConfig = (bundle, format)=>{
    if ('esm' === format || 'cjs' === format) {
        if (bundle) return {
            output: {
                dataUriLimit: 0,
                assetPrefix: 'auto'
            },
            plugins: [
                pluginLibAsset({
                    bundle: true
                })
            ]
        };
        return {
            output: {
                dataUriLimit: 0,
                assetPrefix: 'auto'
            },
            plugins: [
                pluginLibAsset({
                    bundle: false
                })
            ]
        };
    }
    return {};
};
const BASE_URI = 'webpack://';
const AUTO_PUBLIC_PATH = '__mini_css_extract_plugin_public_path_auto__';
const ABSOLUTE_PUBLIC_PATH = `${BASE_URI}/mini-css-extract-plugin/`;
const SINGLE_DOT_PATH_SEGMENT = '__mini_css_extract_plugin_single_dot_path_segment__';
const LibCssExtractPlugin_pluginName = 'LIB_CSS_EXTRACT_PLUGIN';
class LibCssExtractPlugin {
    name = LibCssExtractPlugin_pluginName;
    options;
    constructor(options){
        this.options = options ?? {};
    }
    apply(compiler) {
        compiler.hooks.make.tap(LibCssExtractPlugin_pluginName, (compilation)=>{
            compilation.hooks.processAssets.tap(LibCssExtractPlugin_pluginName, (assets)=>{
                const chunkAsset = Object.keys(assets).filter((name)=>/\.css/.test(name));
                for (const name of chunkAsset)compilation.updateAsset(name, (old)=>{
                    const oldSource = old.source().toString();
                    const replaceSource = new __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.sources.ReplaceSource(old);
                    function replace(searchValue, replaceValue) {
                        let start = oldSource.indexOf(searchValue);
                        while(-1 !== start){
                            replaceSource.replace(start, start + searchValue.length - 1, replaceValue);
                            start = oldSource.indexOf(searchValue, start + 1);
                        }
                    }
                    replace(SINGLE_DOT_PATH_SEGMENT, '.');
                    const undoPath = getUndoPath(name, compilation.outputOptions.path, true);
                    replace(`${ABSOLUTE_PUBLIC_PATH}${AUTO_PUBLIC_PATH}`, undoPath);
                    replace(ABSOLUTE_PUBLIC_PATH, '');
                    replace(`${BASE_URI}/`, '');
                    return replaceSource;
                });
            });
        });
    }
}
const cssConfig_require = createRequire(import.meta.url);
const RSLIB_CSS_ENTRY_FLAG = '__rslib_css__';
async function cssExternalHandler(request, callback, jsExtension, auto, styleRedirectPath, styleRedirectExtension, redirectedPath, issuer) {
    if (/compiled\/css-loader\//.test(request)) return callback();
    let resolvedRequest = request;
    if (styleRedirectPath) {
        if (void 0 === redirectedPath) return false;
        resolvedRequest = redirectedPath;
    }
    if (!isCssFile(resolvedRequest)) {
        if (isCssFile(issuer)) return callback();
        return false;
    }
    if (styleRedirectExtension) {
        const isCssModulesRequest = isCssModulesFile(resolvedRequest, auto);
        if (isCssModulesRequest) return callback(void 0, resolvedRequest.replace(/\.[^.]+$/, jsExtension));
        return callback(void 0, resolvedRequest.replace(/\.[^.]+$/, '.css'));
    }
    return callback(void 0, resolvedRequest);
}
const cssConfig_PLUGIN_NAME = 'rsbuild:lib-css';
const pluginLibCss = (rootDir, auto, banner, footer)=>({
        name: cssConfig_PLUGIN_NAME,
        setup (api) {
            api.processAssets({
                stage: 'additional'
            }, ({ assets, compilation })=>{
                for (const key of Object.keys(assets))if (key.match(RSLIB_CSS_ENTRY_FLAG)) compilation.deleteAsset(key);
            });
            api.modifyBundlerChain((config, { CHAIN_ID })=>{
                let isUsingCssExtract = false;
                for (const ruleId of [
                    CHAIN_ID.RULE.CSS,
                    CHAIN_ID.RULE.SASS,
                    CHAIN_ID.RULE.LESS,
                    CHAIN_ID.RULE.STYLUS
                ]){
                    const rule = config.module.rule(ruleId);
                    if (rule.uses.has(CHAIN_ID.USE.MINI_CSS_EXTRACT)) {
                        isUsingCssExtract = true;
                        rule.use(CHAIN_ID.USE.MINI_CSS_EXTRACT).loader(cssConfig_require.resolve('./libCssExtractLoader.js')).options({
                            rootDir,
                            auto,
                            banner,
                            footer
                        });
                    }
                }
                if (isUsingCssExtract) {
                    const cssExtract = CHAIN_ID.PLUGIN.MINI_CSS_EXTRACT;
                    config.plugins.delete(cssExtract);
                    config.plugin(LibCssExtractPlugin.name).use(LibCssExtractPlugin);
                }
            });
        }
    });
const composeCssConfig = (rootDir, auto, bundle = true, banner, footer)=>{
    if (bundle || null === rootDir) return {};
    return {
        plugins: [
            pluginLibCss(rootDir, auto, banner, footer)
        ],
        tools: {
            cssLoader: {
                import: false
            }
        }
    };
};
const EntryChunkPlugin_require = createRequire(import.meta.url);
const EntryChunkPlugin_PLUGIN_NAME = 'rsbuild:lib-entry-chunk';
const LOADER_NAME = 'rsbuild:lib-entry-module';
const IMPORT_META_URL_SHIM = `const __rslib_import_meta_url__ = /*#__PURE__*/ (function () {
  return typeof document === 'undefined'
    ? new (require('url'.replace('', '')).URL)('file:' + __filename).href
    : (document.currentScript && document.currentScript.src) ||
      new URL('main.js', document.baseURI).href;
})();
`;
const matchFirstLine = (source, regex)=>{
    const lineBreakPos = source.match(/(\r\n|\n)/);
    const firstLineContent = source.slice(0, lineBreakPos?.index);
    const matched = regex.exec(firstLineContent);
    if (!matched) return false;
    return matched[0];
};
class EntryChunkPlugin {
    reactDirectives = {};
    shimsInjectedAssets = new Set();
    shebangChmod = 493;
    shebangEntries = {};
    shebangInjectedAssets = new Set();
    enabledImportMetaUrlShim;
    contextToWatch = null;
    constructor({ enabledImportMetaUrlShim = true, contextToWatch }){
        this.enabledImportMetaUrlShim = enabledImportMetaUrlShim;
        this.contextToWatch = contextToWatch;
    }
    apply(compiler) {
        compiler.hooks.afterCompile.tap(EntryChunkPlugin_PLUGIN_NAME, (compilation)=>{
            if (null === this.contextToWatch) return;
            const contextDep = compilation.contextDependencies;
            if (!contextDep.has(this.contextToWatch)) contextDep.add(this.contextToWatch);
        });
        compiler.hooks.make.tap(EntryChunkPlugin_PLUGIN_NAME, (compilation)=>{
            const entries = {};
            for (const [key, value] of compilation.entries){
                const firstDep = value.dependencies[0];
                if (firstDep?.request) entries[key] = firstDep.request;
            }
            for(const name in entries){
                const first = entries[name];
                if (!first) continue;
                const filename = first.split('?')[0];
                const isJs = JS_EXTENSIONS_PATTERN.test(filename);
                if (!isJs) continue;
                const content = compiler.inputFileSystem.readFileSync(filename, {
                    encoding: 'utf-8'
                });
                if (content.startsWith(SHEBANG_PREFIX)) {
                    const shebangMatch = matchFirstLine(content, SHEBANG_REGEX);
                    if (shebangMatch) this.shebangEntries[name] = shebangMatch;
                }
                const reactDirective = matchFirstLine(content, REACT_DIRECTIVE_REGEX);
                if (reactDirective) this.reactDirectives[name] = reactDirective;
            }
        });
        compiler.hooks.make.tap(EntryChunkPlugin_PLUGIN_NAME, (compilation)=>{
            compilation.hooks.chunkAsset.tap(EntryChunkPlugin_PLUGIN_NAME, (chunk, filename)=>{
                const isJs = JS_EXTENSIONS_PATTERN.test(filename);
                if (!isJs) return;
                const name = chunk.name;
                if (!name) return;
                this.shimsInjectedAssets.add(filename);
                const shebangEntry = this.shebangEntries[name];
                if (shebangEntry) this.shebangEntries[filename] = shebangEntry;
                const reactDirective = this.reactDirectives[name];
                if (reactDirective) this.reactDirectives[filename] = reactDirective;
            });
        });
        compiler.hooks.make.tap(EntryChunkPlugin_PLUGIN_NAME, (compilation)=>{
            compilation.hooks.processAssets.tap(EntryChunkPlugin_PLUGIN_NAME, (assets)=>{
                if (!this.enabledImportMetaUrlShim) return;
                const chunkAsset = Object.keys(assets).filter((name)=>JS_EXTENSIONS_PATTERN.test(name) && this.shimsInjectedAssets.has(name));
                for (const name of chunkAsset)compilation.updateAsset(name, (old)=>{
                    const oldSource = old.source().toString();
                    const replaceSource = new __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.sources.ReplaceSource(old);
                    if (oldSource.startsWith('use strict;') || oldSource.startsWith('"use strict";')) replaceSource.replace(0, 11, `"use strict";\n${IMPORT_META_URL_SHIM}`);
                    else replaceSource.insert(0, IMPORT_META_URL_SHIM);
                    return replaceSource;
                });
            });
            compilation.hooks.processAssets.tap({
                name: EntryChunkPlugin_PLUGIN_NAME,
                stage: __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING - 1
            }, (assets)=>{
                const chunkAsset = Object.keys(assets);
                for (const name of chunkAsset){
                    const shebangValue = this.shebangEntries[name];
                    const reactDirectiveValue = this.reactDirectives[name];
                    if (shebangValue || reactDirectiveValue) compilation.updateAsset(name, (old)=>{
                        const replaceSource = new __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.sources.ReplaceSource(old);
                        if (shebangValue) {
                            replaceSource.insert(0, `${shebangValue}\n`);
                            this.shebangInjectedAssets.add(name);
                        }
                        if (reactDirectiveValue) replaceSource.insert(0, `${reactDirectiveValue}\n`);
                        return replaceSource;
                    });
                }
            });
        });
        compiler.hooks.assetEmitted.tap(EntryChunkPlugin_PLUGIN_NAME, (file, { targetPath })=>{
            if (this.shebangInjectedAssets.has(file)) chmodSync(targetPath, this.shebangChmod);
        });
    }
}
const entryModuleLoaderRsbuildPlugin = ()=>({
        name: EntryChunkPlugin_PLUGIN_NAME,
        setup (api) {
            api.modifyBundlerChain((config, { CHAIN_ID })=>{
                config.module.rule(`Rslib:${CHAIN_ID.RULE.JS}-entry-loader`).test(config.module.rule(CHAIN_ID.RULE.JS).get('test')).issuer(/^$/).use(LOADER_NAME).loader(EntryChunkPlugin_require.resolve('./entryModuleLoader.js'));
            });
        }
    });
const composeEntryChunkConfig = ({ enabledImportMetaUrlShim, contextToWatch = null })=>({
        plugins: [
            entryModuleLoaderRsbuildPlugin()
        ],
        tools: {
            rspack: {
                plugins: [
                    new EntryChunkPlugin({
                        enabledImportMetaUrlShim,
                        contextToWatch
                    })
                ]
            }
        }
    });
const pluginCjsImportMetaUrlShim = ()=>({
        name: 'rsbuild:cjs-import-meta-url-shim',
        setup (api) {
            api.modifyEnvironmentConfig((config)=>{
                config.source.define = {
                    ...config.source.define,
                    'import.meta.url': '__rslib_import_meta_url__'
                };
            });
        }
    });
const requireShim = `// Rslib ESM shims
import __rslib_shim_module__ from 'module';
const require = /*#__PURE__*/ __rslib_shim_module__.createRequire(import.meta.url);
`;
const pluginEsmRequireShim = ()=>({
        name: 'rsbuild:esm-require-shim',
        setup (api) {
            api.modifyRspackConfig((config)=>{
                config.plugins ??= [];
                config.plugins.push(new __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.BannerPlugin({
                    banner: requireShim,
                    stage: __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE - 1,
                    raw: true,
                    include: /\.(js|mjs)$/
                }));
            });
        }
    });
const isDebug = ()=>{
    if (!process.env.DEBUG) return false;
    const values = process.env.DEBUG.toLocaleLowerCase().split(',');
    return [
        'rslib',
        'rs*',
        'rstack',
        '*'
    ].some((key)=>values.includes(key));
};
if (isDebug()) logger.level = 'verbose';
function getTime() {
    const now = new Date();
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    return `${hours}:${minutes}:${seconds}`;
}
logger.override({
    debug: (message, ...args)=>{
        if ('verbose' !== logger.level) return;
        const time = picocolors.gray(`${getTime()}`);
        console.log(`  ${picocolors.green('rslib')} ${time} ${message}`, ...args);
    }
});
const getDefaultExtension = (options)=>{
    const { format, pkgJson, autoExtension } = options;
    let jsExtension = '.js';
    let dtsExtension = '.d.ts';
    if (!autoExtension) return {
        jsExtension,
        dtsExtension
    };
    if (!pkgJson) {
        logger.warn('The `autoExtension` configuration will not be applied due to read package.json failed');
        return {
            jsExtension,
            dtsExtension
        };
    }
    const isModule = 'module' === pkgJson.type;
    if (isModule && 'cjs' === format) {
        jsExtension = '.cjs';
        dtsExtension = '.d.cts';
    }
    if (!isModule && 'esm' === format) {
        jsExtension = '.mjs';
        dtsExtension = '.d.mts';
    }
    return {
        jsExtension,
        dtsExtension,
        isModule
    };
};
const nodeBuiltInModules = [
    'assert',
    'assert/strict',
    'async_hooks',
    'buffer',
    'child_process',
    'cluster',
    'console',
    'constants',
    'crypto',
    'dgram',
    'diagnostics_channel',
    'dns',
    'dns/promises',
    'domain',
    'events',
    'fs',
    'fs/promises',
    'http',
    'http2',
    'https',
    'inspector',
    'inspector/promises',
    'module',
    'net',
    'os',
    'path',
    'path/posix',
    'path/win32',
    'perf_hooks',
    'process',
    'punycode',
    'querystring',
    'readline',
    'readline/promises',
    'repl',
    'stream',
    'stream/consumers',
    'stream/promises',
    'stream/web',
    'string_decoder',
    'sys',
    'timers',
    'timers/promises',
    'tls',
    'trace_events',
    'tty',
    'url',
    'util',
    'util/types',
    'v8',
    'vm',
    'wasi',
    'worker_threads',
    'zlib',
    /^node:/,
    'pnpapi'
];
async function calcLongestCommonPath(absPaths) {
    if (0 === absPaths.length) return null;
    const sep = node_path.posix.sep;
    const splitPaths = absPaths.map((p)=>p.split(sep));
    let lcaFragments = splitPaths[0];
    for(let i = 1; i < splitPaths.length; i++){
        const currentPath = splitPaths[i];
        const minLength = Math.min(lcaFragments.length, currentPath.length);
        let j = 0;
        while(j < minLength && lcaFragments[j] === currentPath[j])j++;
        lcaFragments = lcaFragments.slice(0, j);
    }
    let lca = lcaFragments.length > 0 ? lcaFragments.join(sep) : sep;
    const stats = await node_fs_promises.stat(lca);
    if (stats?.isFile()) lca = node_path.dirname(lca);
    return lca;
}
function getAbsolutePath(base, filepath) {
    return isAbsolute(filepath) ? filepath : join(base, filepath);
}
const readPackageJson = (rootPath)=>{
    const pkgJsonPath = node_path.join(rootPath, './package.json');
    if (!node_fs.existsSync(pkgJsonPath)) return void logger.warn(`The \`package.json\` file does not exist in the ${rootPath} directory`);
    try {
        return JSON.parse(node_fs.readFileSync(pkgJsonPath, 'utf8'));
    } catch (_err) {
        logger.warn(`Failed to parse ${pkgJsonPath}, it might not be valid JSON`);
        return;
    }
};
const isObject = (obj)=>'[object Object]' === Object.prototype.toString.call(obj);
const isEmptyObject = (obj)=>0 === Object.keys(obj).length;
function pick(obj, keys) {
    return keys.reduce((ret, key)=>{
        if (void 0 !== obj[key]) ret[key] = obj[key];
        return ret;
    }, {});
}
function omit(obj, keysObj) {
    return Object.keys(obj).reduce((ret, key)=>{
        if (true !== keysObj[key]) ret[key] = obj[key];
        return ret;
    }, {});
}
function isPluginIncluded(pluginName, plugins) {
    return Boolean(plugins?.some((plugin)=>{
        if (Array.isArray(plugin)) return isPluginIncluded(pluginName, plugin);
        if ('object' == typeof plugin && null !== plugin && 'name' in plugin) return plugin.name === pluginName;
        return false;
    }));
}
function checkMFPlugin(config, sharedPlugins) {
    if ('mf' !== config.format) return true;
    const added = isPluginIncluded('rsbuild:module-federation-enhanced', [
        ...sharedPlugins || [],
        ...config.plugins || []
    ]);
    if (!added) {
        logger.warn(`${picocolors.green('format: "mf"')} should be used with ${picocolors.blue('@module-federation/rsbuild-plugin')}", consider installing and adding it to plugins. Check the documentation (https://module-federation.io/guide/basic/rsbuild.html#rslib-module) to get started with "mf" output.`);
        process.exit(1);
    }
    return added;
}
function debounce(func, wait) {
    let timeoutId = null;
    return (...args)=>{
        if (null !== timeoutId) clearTimeout(timeoutId);
        timeoutId = setTimeout(()=>{
            func(...args);
        }, wait);
    };
}
const isTTY = (type = 'stdout')=>('stdin' === type ? process.stdin.isTTY : process.stdout.isTTY) && !process.env.CI;
const isIntermediateOutputFormat = (format)=>'cjs' === format || 'esm' === format;
const windowsSlashRegex = /\\/g;
function normalizeSlash(p) {
    return p.replace(windowsSlashRegex, '/');
}
const LATEST_TARGET_VERSIONS = {
    node: [
        'last 1 node versions'
    ],
    web: [
        'last 1 Chrome versions',
        'last 1 Firefox versions',
        'last 1 Edge versions',
        'last 1 Safari versions',
        'last 1 ios_saf versions',
        'not dead'
    ],
    get 'web-worker' () {
        return LATEST_TARGET_VERSIONS.web;
    }
};
const calcEsnextBrowserslistByTarget = (target)=>{
    if ('node' === target) return LATEST_TARGET_VERSIONS.node;
    return LATEST_TARGET_VERSIONS.web;
};
const RSPACK_TARGET_UNLISTED_MODERN_ECMA_VERSIONS = [
    'es2023',
    'es2024',
    'esnext'
];
const ESX_TO_BROWSERSLIST = {
    es5: {
        chrome: '5.0.0',
        edge: '12.0.0',
        firefox: '2.0.0',
        ie: '9.0.0',
        ios: '6.0.0',
        node: '0.4.0',
        opera: '10.10.0',
        safari: '3.1.0'
    },
    es6: {
        chrome: '63.0.0',
        edge: '79.0.0',
        firefox: '67.0.0',
        ios: '13.0.0',
        node: '13.2.0',
        opera: '50.0.0',
        safari: '13.0.0'
    },
    es2015: {
        chrome: '63.0.0',
        edge: '79.0.0',
        firefox: '67.0.0',
        ios: '13.0.0',
        node: '13.2.0',
        opera: '50.0.0',
        safari: '13.0.0'
    },
    es2016: {
        chrome: '63.0.0',
        edge: '79.0.0',
        firefox: '67.0.0',
        ios: '13.0.0',
        node: '13.2.0',
        opera: '50.0.0',
        safari: '13.0.0'
    },
    es2017: {
        chrome: '63.0.0',
        edge: '79.0.0',
        firefox: '67.0.0',
        ios: '13.0.0',
        node: '13.2.0',
        opera: '50.0.0',
        safari: '13.0.0'
    },
    es2018: {
        chrome: '64.0.0',
        edge: '79.0.0',
        firefox: '78.0.0',
        ios: '16.4.0',
        node: '13.2.0',
        opera: '51.0.0',
        safari: '16.4.0'
    },
    es2019: {
        chrome: '66.0.0',
        edge: '79.0.0',
        firefox: '78.0.0',
        ios: '16.4.0',
        node: '13.2.0',
        opera: '53.0.0',
        safari: '16.4.0'
    },
    es2020: {
        chrome: '91.0.0',
        edge: '91.0.0',
        firefox: '80.0.0',
        ios: '16.4.0',
        node: '16.1.0',
        opera: '77.0.0',
        safari: '16.4.0'
    },
    es2021: {
        chrome: '91.0.0',
        edge: '91.0.0',
        firefox: '80.0.0',
        ios: '16.4.0',
        node: '16.1.0',
        opera: '77.0.0',
        safari: '16.4.0'
    },
    es2022: {
        chrome: '91.0.0',
        firefox: '93.0.0',
        ios: '16.4.0',
        node: '16.11.0',
        safari: '16.4.0'
    },
    es2023: {
        chrome: '91.0.0',
        firefox: '93.0.0',
        ios: '16.4.0',
        node: '16.11.0',
        safari: '16.4.0'
    },
    es2024: calcEsnextBrowserslistByTarget,
    esnext: calcEsnextBrowserslistByTarget
};
function transformSyntaxToRspackTarget(syntax) {
    const handleSyntaxItem = (syntaxItem)=>{
        const normalizedSyntaxItem = syntaxItem.toLowerCase();
        if (normalizedSyntaxItem.startsWith('es')) {
            if (normalizedSyntaxItem in ESX_TO_BROWSERSLIST) {
                if (RSPACK_TARGET_UNLISTED_MODERN_ECMA_VERSIONS.includes(normalizedSyntaxItem)) return 'es2022';
                if ('es6' === normalizedSyntaxItem) return 'es2015';
                return normalizedSyntaxItem;
            }
            throw new Error(`Unsupported ES version: ${syntaxItem}`);
        }
        return `browserslist:${syntaxItem}`;
    };
    if (Array.isArray(syntax)) return syntax.map(handleSyntaxItem);
    return [
        handleSyntaxItem(syntax)
    ];
}
function transformSyntaxToBrowserslist(syntax, target) {
    const handleSyntaxItem = (syntaxItem)=>{
        const normalizedSyntaxItem = syntaxItem.toLowerCase();
        if (normalizedSyntaxItem.startsWith('es')) {
            if (normalizedSyntaxItem in ESX_TO_BROWSERSLIST) {
                const browserslistItem = ESX_TO_BROWSERSLIST[normalizedSyntaxItem];
                if ('function' == typeof browserslistItem) return browserslistItem(target);
                return Object.entries(browserslistItem).flatMap(([engine, version])=>{
                    if (Array.isArray(version)) return version;
                    return `${engine} >= ${version}`;
                });
            }
            throw new Error(`Unsupported ES version: ${syntaxItem}`);
        }
        return [
            syntaxItem
        ];
    };
    if (Array.isArray(syntax)) return syntax.flatMap(handleSyntaxItem);
    return handleSyntaxItem(syntax);
}
const POSIX_SEP_RE = new RegExp('\\' + node_path.posix.sep, 'g');
const NATIVE_SEP_RE = new RegExp('\\' + node_path.sep, 'g');
const PATTERN_REGEX_CACHE = new Map();
const GLOB_ALL_PATTERN = "**/*";
const TS_EXTENSIONS = [
    '.ts',
    '.tsx',
    '.mts',
    '.cts'
];
const util_JS_EXTENSIONS = [
    '.js',
    '.jsx',
    '.mjs',
    '.cjs'
];
const TSJS_EXTENSIONS = TS_EXTENSIONS.concat(util_JS_EXTENSIONS);
const TS_EXTENSIONS_RE_GROUP = `\\.(?:${TS_EXTENSIONS.map((ext)=>ext.substring(1)).join('|')})`;
const TSJS_EXTENSIONS_RE_GROUP = `\\.(?:${TSJS_EXTENSIONS.map((ext)=>ext.substring(1)).join('|')})`;
const IS_POSIX = node_path.posix.sep === node_path.sep;
function util_makePromise() {
    let resolve, reject;
    const promise = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    return {
        promise,
        resolve,
        reject
    };
}
async function util_resolveTSConfigJson(filename, cache) {
    if ('.json' !== node_path.extname(filename)) return;
    const tsconfig = node_path.resolve(filename);
    if (cache && (cache.hasParseResult(tsconfig) || cache.hasParseResult(filename))) return tsconfig;
    return promises.stat(tsconfig).then((stat)=>{
        if (stat.isFile() || stat.isFIFO()) return tsconfig;
        throw new Error(`${filename} exists but is not a regular file.`);
    });
}
const util_isInNodeModules = IS_POSIX ? (dir)=>dir.includes('/node_modules/') : (dir)=>dir.match(/[/\\]node_modules[/\\]/);
const posix2native = IS_POSIX ? (filename)=>filename : (filename)=>filename.replace(POSIX_SEP_RE, node_path.sep);
const util_native2posix = IS_POSIX ? (filename)=>filename : (filename)=>filename.replace(NATIVE_SEP_RE, node_path.posix.sep);
const resolve2posix = IS_POSIX ? (dir, filename)=>dir ? node_path.resolve(dir, filename) : node_path.resolve(filename) : (dir, filename)=>util_native2posix(dir ? node_path.resolve(posix2native(dir), posix2native(filename)) : node_path.resolve(posix2native(filename)));
function util_resolveReferencedTSConfigFiles(result, options) {
    const dir = node_path.dirname(result.tsconfigFile);
    return result.tsconfig.references.map((ref)=>{
        const refPath = ref.path.endsWith('.json') ? ref.path : node_path.join(ref.path, options?.configName ?? 'tsconfig.json');
        return resolve2posix(dir, refPath);
    });
}
function util_resolveSolutionTSConfig(filename, result) {
    const allowJs = result.tsconfig.compilerOptions?.allowJs;
    const extensions = allowJs ? TSJS_EXTENSIONS : TS_EXTENSIONS;
    if (result.referenced && extensions.some((ext)=>filename.endsWith(ext)) && !util_isIncluded(filename, result)) {
        const solutionTSConfig = result.referenced.find((referenced)=>util_isIncluded(filename, referenced));
        if (solutionTSConfig) return solutionTSConfig;
    }
    return result;
}
function util_isIncluded(filename, result) {
    const dir = util_native2posix(node_path.dirname(result.tsconfigFile));
    const files = (result.tsconfig.files || []).map((file)=>resolve2posix(dir, file));
    const absoluteFilename = resolve2posix(null, filename);
    if (files.includes(filename)) return true;
    const allowJs = result.tsconfig.compilerOptions?.allowJs;
    const isIncluded = isGlobMatch(absoluteFilename, dir, result.tsconfig.include || (result.tsconfig.files ? [] : [
        GLOB_ALL_PATTERN
    ]), allowJs);
    if (isIncluded) {
        const isExcluded = isGlobMatch(absoluteFilename, dir, result.tsconfig.exclude || [], allowJs);
        return !isExcluded;
    }
    return false;
}
function isGlobMatch(filename, dir, patterns, allowJs) {
    const extensions = allowJs ? TSJS_EXTENSIONS : TS_EXTENSIONS;
    return patterns.some((pattern)=>{
        let lastWildcardIndex = pattern.length;
        let hasWildcard = false;
        let hasExtension = false;
        let hasSlash = false;
        let lastSlashIndex = -1;
        for(let i = pattern.length - 1; i > -1; i--){
            const c = pattern[i];
            if (!hasWildcard) {
                if ('*' === c || '?' === c) {
                    lastWildcardIndex = i;
                    hasWildcard = true;
                }
            }
            if (!hasSlash) {
                if ('.' === c) hasExtension = true;
                else if ('/' === c) {
                    lastSlashIndex = i;
                    hasSlash = true;
                }
            }
            if (hasWildcard && hasSlash) break;
        }
        if (!hasExtension && (!hasWildcard || lastWildcardIndex < lastSlashIndex)) {
            pattern += `${pattern.endsWith('/') ? '' : '/'}${GLOB_ALL_PATTERN}`;
            lastWildcardIndex = pattern.length - 1;
            hasWildcard = true;
        }
        if (lastWildcardIndex < pattern.length - 1 && !filename.endsWith(pattern.slice(lastWildcardIndex + 1))) return false;
        if (pattern.endsWith('*') && !extensions.some((ext)=>filename.endsWith(ext))) return false;
        if (pattern === GLOB_ALL_PATTERN) return filename.startsWith(`${dir}/`);
        const resolvedPattern = resolve2posix(dir, pattern);
        let firstWildcardIndex = -1;
        for(let i = 0; i < resolvedPattern.length; i++)if ('*' === resolvedPattern[i] || '?' === resolvedPattern[i]) {
            firstWildcardIndex = i;
            hasWildcard = true;
            break;
        }
        if (firstWildcardIndex > 1 && !filename.startsWith(resolvedPattern.slice(0, firstWildcardIndex - 1))) return false;
        if (!hasWildcard) return filename === resolvedPattern;
        if (firstWildcardIndex + GLOB_ALL_PATTERN.length === resolvedPattern.length - (pattern.length - 1 - lastWildcardIndex) && resolvedPattern.slice(firstWildcardIndex, firstWildcardIndex + GLOB_ALL_PATTERN.length) === GLOB_ALL_PATTERN) return true;
        if (PATTERN_REGEX_CACHE.has(resolvedPattern)) return PATTERN_REGEX_CACHE.get(resolvedPattern).test(filename);
        const regex = pattern2regex(resolvedPattern, allowJs);
        PATTERN_REGEX_CACHE.set(resolvedPattern, regex);
        return regex.test(filename);
    });
}
function pattern2regex(resolvedPattern, allowJs) {
    let regexStr = '^';
    for(let i = 0; i < resolvedPattern.length; i++){
        const char = resolvedPattern[i];
        if ('?' === char) {
            regexStr += '[^\\/]';
            continue;
        }
        if ('*' === char) {
            if ('*' === resolvedPattern[i + 1] && '/' === resolvedPattern[i + 2]) {
                i += 2;
                regexStr += '(?:[^\\/]*\\/)*';
                continue;
            }
            regexStr += '[^\\/]*';
            continue;
        }
        if ('/.+^${}()|[]\\'.includes(char)) regexStr += "\\";
        regexStr += char;
    }
    if (resolvedPattern.endsWith('*')) regexStr += allowJs ? TSJS_EXTENSIONS_RE_GROUP : TS_EXTENSIONS_RE_GROUP;
    regexStr += '$';
    return new RegExp(regexStr);
}
function util_replaceTokens(result) {
    if (result.tsconfig) result.tsconfig = JSON.parse(JSON.stringify(result.tsconfig).replaceAll(/"\${configDir}/g, `"${util_native2posix(node_path.dirname(result.tsconfigFile))}`));
}
async function find(filename, options) {
    let dir = node_path.dirname(node_path.resolve(filename));
    if (options?.ignoreNodeModules && util_isInNodeModules(dir)) return null;
    const cache = options?.cache;
    const configName = options?.configName ?? 'tsconfig.json';
    if (cache?.hasConfigPath(dir, configName)) return cache.getConfigPath(dir, configName);
    const { promise, resolve, reject } = util_makePromise();
    if (options?.root && !node_path.isAbsolute(options.root)) options.root = node_path.resolve(options.root);
    findUp(dir, {
        promise,
        resolve,
        reject
    }, options);
    return promise;
}
function findUp(dir, { resolve, reject, promise }, options) {
    const { cache, root, configName } = options ?? {};
    if (cache) if (cache.hasConfigPath(dir, configName)) {
        let cached;
        try {
            cached = cache.getConfigPath(dir, configName);
        } catch (e) {
            reject(e);
            return;
        }
        if (cached?.then) cached.then(resolve).catch(reject);
        else resolve(cached);
    } else cache.setConfigPath(dir, promise, configName);
    const tsconfig = node_path.join(dir, options?.configName ?? 'tsconfig.json');
    node_fs.stat(tsconfig, (err, stats)=>{
        if (stats && (stats.isFile() || stats.isFIFO())) resolve(tsconfig);
        else if (err?.code !== 'ENOENT') reject(err);
        else {
            let parent;
            if (root === dir || (parent = node_path.dirname(dir)) === dir) resolve(null);
            else findUp(parent, {
                promise,
                resolve,
                reject
            }, options);
        }
    });
}
node_path.sep;
function toJson(tsconfigJson) {
    const stripped = stripDanglingComma(stripJsonComments(stripBom(tsconfigJson)));
    if ('' === stripped.trim()) return '{}';
    return stripped;
}
function stripDanglingComma(pseudoJson) {
    let insideString = false;
    let offset = 0;
    let result = '';
    let danglingCommaPos = null;
    for(let i = 0; i < pseudoJson.length; i++){
        const currentCharacter = pseudoJson[i];
        if ('"' === currentCharacter) {
            const escaped = isEscaped(pseudoJson, i);
            if (!escaped) insideString = !insideString;
        }
        if (insideString) {
            danglingCommaPos = null;
            continue;
        }
        if (',' === currentCharacter) {
            danglingCommaPos = i;
            continue;
        }
        if (danglingCommaPos) {
            if ('}' === currentCharacter || ']' === currentCharacter) {
                result += pseudoJson.slice(offset, danglingCommaPos) + ' ';
                offset = danglingCommaPos + 1;
                danglingCommaPos = null;
            } else if (!currentCharacter.match(/\s/)) danglingCommaPos = null;
        }
    }
    return result + pseudoJson.substring(offset);
}
function isEscaped(jsonString, quotePosition) {
    let index = quotePosition - 1;
    let backslashCount = 0;
    while('\\' === jsonString[index]){
        index -= 1;
        backslashCount += 1;
    }
    return Boolean(backslashCount % 2);
}
function strip(string, start, end) {
    return string.slice(start, end).replace(/\S/g, ' ');
}
const singleComment = Symbol('singleComment');
const multiComment = Symbol('multiComment');
function stripJsonComments(jsonString) {
    let isInsideString = false;
    let isInsideComment = false;
    let offset = 0;
    let result = '';
    for(let index = 0; index < jsonString.length; index++){
        const currentCharacter = jsonString[index];
        const nextCharacter = jsonString[index + 1];
        if (!isInsideComment && '"' === currentCharacter) {
            const escaped = isEscaped(jsonString, index);
            if (!escaped) isInsideString = !isInsideString;
        }
        if (!isInsideString) if (isInsideComment || currentCharacter + nextCharacter !== '//') if (isInsideComment === singleComment && currentCharacter + nextCharacter === '\r\n') {
            index++;
            isInsideComment = false;
            result += strip(jsonString, offset, index);
            offset = index;
        } else if (isInsideComment === singleComment && '\n' === currentCharacter) {
            isInsideComment = false;
            result += strip(jsonString, offset, index);
            offset = index;
        } else if (isInsideComment || currentCharacter + nextCharacter !== '/*') {
            if (isInsideComment === multiComment && currentCharacter + nextCharacter === '*/') {
                index++;
                isInsideComment = false;
                result += strip(jsonString, offset, index + 1);
                offset = index + 1;
            }
        } else {
            result += jsonString.slice(offset, index);
            offset = index;
            isInsideComment = multiComment;
            index++;
        }
        else {
            result += jsonString.slice(offset, index);
            offset = index;
            isInsideComment = singleComment;
            index++;
        }
    }
    return result + (isInsideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
}
function stripBom(string) {
    if (0xfeff === string.charCodeAt(0)) return string.slice(1);
    return string;
}
const not_found_result = {
    tsconfigFile: null,
    tsconfig: {}
};
async function parse_parse(filename, options) {
    const cache = options?.cache;
    if (cache?.hasParseResult(filename)) return getParsedDeep(filename, cache, options);
    const { resolve, reject, promise } = util_makePromise();
    cache?.setParseResult(filename, promise, true);
    try {
        let tsconfigFile = await util_resolveTSConfigJson(filename, cache) || await find(filename, options);
        if (!tsconfigFile) {
            resolve(not_found_result);
            return promise;
        }
        let result;
        if (filename !== tsconfigFile && cache?.hasParseResult(tsconfigFile)) result = await getParsedDeep(tsconfigFile, cache, options);
        else {
            result = await parseFile(tsconfigFile, cache, filename === tsconfigFile);
            await Promise.all([
                parseExtends(result, cache),
                parseReferences(result, options)
            ]);
        }
        util_replaceTokens(result);
        resolve(util_resolveSolutionTSConfig(filename, result));
    } catch (e) {
        reject(e);
    }
    return promise;
}
async function getParsedDeep(filename, cache, options) {
    const result = await cache.getParseResult(filename);
    if (result.tsconfig.extends && !result.extended || result.tsconfig.references && !result.referenced) {
        const promise = Promise.all([
            parseExtends(result, cache),
            parseReferences(result, options)
        ]).then(()=>result);
        cache.setParseResult(filename, promise, true);
        return promise;
    }
    return result;
}
async function parseFile(tsconfigFile, cache, skipCache) {
    if (!skipCache && cache?.hasParseResult(tsconfigFile) && !cache.getParseResult(tsconfigFile)._isRootFile_) return cache.getParseResult(tsconfigFile);
    const promise = promises.readFile(tsconfigFile, 'utf-8').then(toJson).then((json)=>{
        const parsed = JSON.parse(json);
        applyDefaults(parsed, tsconfigFile);
        return {
            tsconfigFile,
            tsconfig: normalizeTSConfig(parsed, node_path.dirname(tsconfigFile))
        };
    }).catch((e)=>{
        throw new TSConfckParseError(`parsing ${tsconfigFile} failed: ${e}`, 'PARSE_FILE', tsconfigFile, e);
    });
    if (!skipCache && (!cache?.hasParseResult(tsconfigFile) || !cache.getParseResult(tsconfigFile)._isRootFile_)) cache?.setParseResult(tsconfigFile, promise);
    return promise;
}
function normalizeTSConfig(tsconfig, dir) {
    const baseUrl = tsconfig.compilerOptions?.baseUrl;
    if (baseUrl && !baseUrl.startsWith('${') && !node_path.isAbsolute(baseUrl)) tsconfig.compilerOptions.baseUrl = resolve2posix(dir, baseUrl);
    return tsconfig;
}
async function parseReferences(result, options) {
    if (!result.tsconfig.references) return;
    const referencedFiles = util_resolveReferencedTSConfigFiles(result, options);
    const referenced = await Promise.all(referencedFiles.map((file)=>parseFile(file, options?.cache)));
    await Promise.all(referenced.map((ref)=>parseExtends(ref, options?.cache)));
    referenced.forEach((ref)=>{
        ref.solution = result;
        util_replaceTokens(ref);
    });
    result.referenced = referenced;
}
async function parseExtends(result, cache) {
    if (!result.tsconfig.extends) return;
    const extended = [
        {
            tsconfigFile: result.tsconfigFile,
            tsconfig: JSON.parse(JSON.stringify(result.tsconfig))
        }
    ];
    let pos = 0;
    const extendsPath = [];
    let currentBranchDepth = 0;
    while(pos < extended.length){
        const extending = extended[pos];
        extendsPath.push(extending.tsconfigFile);
        if (extending.tsconfig.extends) {
            currentBranchDepth += 1;
            let resolvedExtends;
            resolvedExtends = Array.isArray(extending.tsconfig.extends) ? extending.tsconfig.extends.reverse().map((ex)=>resolveExtends(ex, extending.tsconfigFile)) : [
                resolveExtends(extending.tsconfig.extends, extending.tsconfigFile)
            ];
            const circularExtends = resolvedExtends.find((tsconfigFile)=>extendsPath.includes(tsconfigFile));
            if (circularExtends) {
                const circle = extendsPath.concat([
                    circularExtends
                ]).join(' -> ');
                throw new TSConfckParseError(`Circular dependency in "extends": ${circle}`, 'EXTENDS_CIRCULAR', result.tsconfigFile);
            }
            extended.splice(pos + 1, 0, ...await Promise.all(resolvedExtends.map((file)=>parseFile(file, cache))));
        } else {
            extendsPath.splice(-currentBranchDepth);
            currentBranchDepth = 0;
        }
        pos += 1;
    }
    result.extended = extended;
    for (const ext of result.extended.slice(1))extendTSConfig(result, ext);
}
function resolveExtends(extended, from) {
    if ([
        '.',
        '..'
    ].includes(extended)) extended += '/tsconfig.json';
    const req = external_module_createRequire(from);
    let error;
    try {
        return req.resolve(extended);
    } catch (e) {
        error = e;
    }
    if ('.' !== extended[0] && !node_path.isAbsolute(extended)) try {
        return req.resolve(`${extended}/tsconfig.json`);
    } catch (e) {
        error = e;
    }
    throw new TSConfckParseError(`failed to resolve "extends":"${extended}" in ${from}`, 'EXTENDS_RESOLVE', from, error);
}
const EXTENDABLE_KEYS = [
    'compilerOptions',
    'files',
    'include',
    'exclude',
    'watchOptions',
    'compileOnSave',
    'typeAcquisition',
    'buildOptions'
];
function extendTSConfig(extending, extended) {
    const extendingConfig = extending.tsconfig;
    const extendedConfig = extended.tsconfig;
    const relativePath = util_native2posix(node_path.relative(node_path.dirname(extending.tsconfigFile), node_path.dirname(extended.tsconfigFile)));
    for (const key of Object.keys(extendedConfig).filter((key)=>EXTENDABLE_KEYS.includes(key)))if ('compilerOptions' === key) {
        if (!extendingConfig.compilerOptions) extendingConfig.compilerOptions = {};
        for (const option of Object.keys(extendedConfig.compilerOptions))if (!Object.prototype.hasOwnProperty.call(extendingConfig.compilerOptions, option)) extendingConfig.compilerOptions[option] = rebaseRelative(option, extendedConfig.compilerOptions[option], relativePath);
    } else if (void 0 === extendingConfig[key]) if ('watchOptions' === key) {
        extendingConfig.watchOptions = {};
        for (const option of Object.keys(extendedConfig.watchOptions))extendingConfig.watchOptions[option] = rebaseRelative(option, extendedConfig.watchOptions[option], relativePath);
    } else extendingConfig[key] = rebaseRelative(key, extendedConfig[key], relativePath);
}
const REBASE_KEYS = [
    'files',
    'include',
    'exclude',
    'baseUrl',
    'rootDir',
    'rootDirs',
    'typeRoots',
    'outDir',
    'outFile',
    'declarationDir',
    'excludeDirectories',
    'excludeFiles'
];
function rebaseRelative(key, value, prependPath) {
    if (!REBASE_KEYS.includes(key)) return value;
    if (Array.isArray(value)) return value.map((x)=>rebasePath(x, prependPath));
    return rebasePath(value, prependPath);
}
function rebasePath(value, prependPath) {
    if (node_path.isAbsolute(value) || value.startsWith('${configDir}')) return value;
    return node_path.posix.normalize(node_path.posix.join(prependPath, value));
}
class TSConfckParseError extends Error {
    code;
    cause;
    tsconfigFile;
    constructor(message, code, tsconfigFile, cause){
        super(message);
        Object.setPrototypeOf(this, TSConfckParseError.prototype);
        this.name = TSConfckParseError.name;
        this.code = code;
        this.cause = cause;
        this.tsconfigFile = tsconfigFile;
    }
}
function applyDefaults(tsconfig, tsconfigFile) {
    if (isJSConfig(tsconfigFile)) tsconfig.compilerOptions = {
        ...DEFAULT_JSCONFIG_COMPILER_OPTIONS,
        ...tsconfig.compilerOptions
    };
}
const DEFAULT_JSCONFIG_COMPILER_OPTIONS = {
    allowJs: true,
    maxNodeModuleJsDepth: 2,
    allowSyntheticDefaultImports: true,
    skipLibCheck: true,
    noEmit: true
};
function isJSConfig(configFileName) {
    return 'jsconfig.json' === node_path.basename(configFileName);
}
async function loadTsconfig(root, tsconfigPath = 'tsconfig.json') {
    const tsconfigFileName = await find(join(root, tsconfigPath), {
        root,
        configName: basename(tsconfigPath)
    });
    if (tsconfigFileName) {
        const { tsconfig } = await parse_parse(tsconfigFileName);
        return tsconfig;
    }
    return {};
}
function defineConfig(config) {
    return config;
}
const findConfig = (basePath)=>DEFAULT_CONFIG_EXTENSIONS.map((ext)=>basePath + ext).find(node_fs.existsSync);
const resolveConfigPath = (root, customConfig)=>{
    if (customConfig) {
        const customConfigPath = isAbsolute(customConfig) ? customConfig : join(root, customConfig);
        if (node_fs.existsSync(customConfigPath)) return customConfigPath;
        logger.warn(`Cannot find config file: ${picocolors.dim(customConfigPath)}\n`);
    }
    const configFilePath = findConfig(join(root, DEFAULT_CONFIG_NAME));
    if (configFilePath) return configFilePath;
    throw new Error(`${DEFAULT_CONFIG_NAME} not found in ${root}`);
};
async function loadConfig({ cwd = process.cwd(), path, envMode }) {
    const configFilePath = resolveConfigPath(cwd, path);
    const { content } = await (0, __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.loadConfig)({
        cwd: dirname(configFilePath),
        path: configFilePath,
        envMode
    });
    return {
        content: content,
        filePath: configFilePath
    };
}
const handleMatchedExternal = (value, request)=>{
    if ('boolean' == typeof value) return value;
    if ('string' == typeof value) {
        const [first, second] = value.split(' ');
        const hasType = !!second;
        const _request = second ? second : first;
        if (!hasType) return request === _request;
        return false;
    }
    if (Array.isArray(value)) return handleMatchedExternal(value[0] ?? '', request);
    return false;
};
const composeExternalsWarnConfig = (format, ...externalsArray)=>{
    if ('esm' !== format) return {};
    const externals = [];
    for (const e of externalsArray.filter(Boolean))if (Array.isArray(e)) externals.push(...e);
    else externals.push(e);
    const matchUserExternals = (externals, request, callback)=>{
        if ('string' == typeof externals) {
            if (handleMatchedExternal(externals, request)) return void callback(true, true);
        }
        if (Array.isArray(externals)) {
            let i = 0;
            const next = ()=>{
                let asyncFlag;
                const handleExternalsAndCallback = (matched, shouldWarn)=>{
                    if (!matched) {
                        if (asyncFlag) {
                            asyncFlag = false;
                            return;
                        }
                        return next();
                    }
                    callback(matched, shouldWarn);
                };
                do {
                    asyncFlag = true;
                    if (i >= externals.length) return callback(false);
                    matchUserExternals(externals[i++], request, handleExternalsAndCallback);
                }while (!asyncFlag);
                asyncFlag = false;
            };
            next();
            return;
        }
        if (externals instanceof RegExp) {
            if (externals.test(request)) return void callback(true, true);
        } else if ('function' == typeof externals) ;
        else if ('object' == typeof externals) {
            if (Object.hasOwn(externals, request)) return void (handleMatchedExternal(externals[request], request) ? callback(true, true) : callback(true));
        }
        callback(false);
    };
    return {
        output: {
            externals: [
                ({ request, dependencyType, contextInfo }, callback)=>{
                    let shouldWarn = false;
                    const _callback = (_matched, _shouldWarn)=>{
                        if (_shouldWarn) shouldWarn = true;
                    };
                    if (contextInfo.issuer && 'commonjs' === dependencyType) {
                        matchUserExternals(externals, request, _callback);
                        if (shouldWarn) logger.warn(composeModuleImportWarn(request, contextInfo.issuer));
                    }
                    callback();
                }
            ]
        }
    };
};
const getAutoExternalDefaultValue = (format, autoExternal)=>autoExternal ?? isIntermediateOutputFormat(format);
const composeAutoExternalConfig = (options)=>{
    const { bundle, format, pkgJson, userExternals } = options;
    if (false === bundle) return {};
    const autoExternal = getAutoExternalDefaultValue(format, options.autoExternal);
    if (false === autoExternal) return {};
    if (!pkgJson) {
        logger.warn('The `autoExternal` configuration will not be applied due to read package.json failed');
        return {};
    }
    const userExternalKeys = userExternals && isObject(userExternals) ? Object.keys(userExternals) : [];
    const externalOptions = {
        dependencies: true,
        optionalDependencies: true,
        peerDependencies: true,
        devDependencies: false,
        ...true === autoExternal ? {} : autoExternal
    };
    const externals = [
        'dependencies',
        'peerDependencies',
        'devDependencies',
        'optionalDependencies'
    ].reduce((prev, type)=>{
        if (externalOptions[type]) return pkgJson[type] ? prev.concat(Object.keys(pkgJson[type])) : prev;
        return prev;
    }, []).filter((name)=>!userExternalKeys.includes(name));
    const uniqueExternals = Array.from(new Set(externals));
    return externals.length ? {
        output: {
            externals: [
                ...uniqueExternals.map((dep)=>new RegExp(`^${dep}($|\\/|\\\\)`)),
                ...uniqueExternals
            ]
        }
    } : {};
};
function composeMinifyConfig(config) {
    const minify = config.output?.minify;
    const format = config.format;
    if (void 0 !== minify) return {};
    return {
        output: {
            minify: {
                js: true,
                css: false,
                jsOptions: {
                    minimizerOptions: {
                        mangle: false,
                        minify: 'mf' === format,
                        compress: {
                            defaults: false,
                            unused: true,
                            dead_code: true,
                            toplevel: 'mf' !== format
                        },
                        format: {
                            comments: 'some',
                            preserve_annotations: true
                        }
                    }
                }
            }
        }
    };
}
function composeBannerFooterConfig(banner, footer) {
    const bannerConfig = pick(banner, [
        'js',
        'css'
    ]);
    const footerConfig = pick(footer, [
        'js',
        'css'
    ]);
    if (isEmptyObject(bannerConfig) && isEmptyObject(footerConfig)) return {};
    const plugins = [];
    if (!isEmptyObject(bannerConfig)) {
        if (bannerConfig.js) plugins.push(new __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.BannerPlugin({
            banner: bannerConfig.js,
            stage: __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE + 1,
            raw: true,
            include: /\.(js|mjs|cjs)$/
        }));
        if (bannerConfig.css) plugins.push(new __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.BannerPlugin({
            banner: bannerConfig.css,
            stage: __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE + 1,
            raw: true,
            include: /\.(css)$/
        }));
    }
    if (!isEmptyObject(footerConfig)) {
        if (footerConfig.js) plugins.push(new __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.BannerPlugin({
            banner: footerConfig.js,
            stage: __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE + 1,
            raw: true,
            footer: true,
            include: /\.(js|mjs|cjs)$/
        }));
        if (footerConfig.css) plugins.push(new __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.BannerPlugin({
            banner: footerConfig.css,
            stage: __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE + 1,
            raw: true,
            footer: true,
            include: /\.(css)$/
        }));
    }
    return {
        tools: {
            rspack: {
                plugins
            }
        }
    };
}
function composeDecoratorsConfig(compilerOptions, version) {
    if (version || !compilerOptions?.experimentalDecorators) return {};
    return {
        source: {
            decorators: {
                version: 'legacy'
            }
        }
    };
}
async function createConstantRsbuildConfig() {
    return (0, __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.defineConfig)({
        performance: {
            chunkSplit: {
                strategy: 'custom'
            }
        },
        tools: {
            htmlPlugin: false,
            rspack: {
                optimization: {
                    splitChunks: {
                        chunks: 'async'
                    },
                    moduleIds: 'named',
                    nodeEnv: false
                },
                experiments: {
                    rspackFuture: {
                        bundlerInfo: {
                            force: false
                        }
                    }
                },
                resolve: {
                    extensionAlias: {
                        '.js': [
                            '.ts',
                            '.tsx',
                            '.js',
                            '.jsx'
                        ],
                        '.jsx': [
                            '.tsx',
                            '.jsx'
                        ],
                        '.mjs': [
                            '.mts',
                            '.mjs'
                        ],
                        '.cjs': [
                            '.cts',
                            '.cjs'
                        ]
                    }
                }
            }
        },
        output: {
            target: 'node',
            filenameHash: false,
            distPath: {
                js: './',
                jsAsync: './',
                css: './',
                cssAsync: './'
            }
        }
    });
}
const composeFormatConfig = ({ format, bundle = true, umdName, pkgJson })=>{
    const jsParserOptions = {
        cjs: {
            requireResolve: false,
            requireDynamic: false,
            requireAsExpression: false
        },
        esm: {
            importMeta: false,
            importDynamic: false
        },
        others: {
            worker: false
        }
    };
    const plugins = [
        new __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack.experiments.RslibPlugin({
            interceptApiPlugin: true
        })
    ];
    switch(format){
        case 'esm':
            return {
                tools: {
                    rspack: {
                        module: {
                            parser: {
                                javascript: {
                                    ...jsParserOptions.esm,
                                    ...jsParserOptions.cjs,
                                    ...jsParserOptions.others
                                }
                            }
                        },
                        optimization: {
                            concatenateModules: true,
                            sideEffects: 'flag',
                            avoidEntryIife: true
                        },
                        output: {
                            module: true,
                            chunkFormat: 'module',
                            library: {
                                type: 'modern-module'
                            },
                            chunkLoading: 'import',
                            workerChunkLoading: 'import',
                            wasmLoading: 'fetch'
                        },
                        experiments: {
                            outputModule: true
                        },
                        plugins
                    }
                }
            };
        case 'cjs':
            return {
                tools: {
                    rspack: {
                        module: {
                            parser: {
                                javascript: {
                                    ...jsParserOptions.esm,
                                    ...jsParserOptions.cjs,
                                    ...jsParserOptions.others
                                }
                            }
                        },
                        output: {
                            iife: false,
                            chunkFormat: 'commonjs',
                            library: {
                                type: 'commonjs-static'
                            },
                            chunkLoading: 'require',
                            workerChunkLoading: 'async-node',
                            wasmLoading: 'async-node'
                        },
                        plugins
                    }
                }
            };
        case 'umd':
            {
                if (false === bundle) throw new Error('When using "umd" format, "bundle" must be set to "true". Since the default value for "bundle" is "true", so you can either explicitly set it to "true" or remove the field entirely.');
                const config = {
                    tools: {
                        rspack: {
                            module: {
                                parser: {
                                    javascript: {
                                        importMeta: false
                                    }
                                }
                            },
                            output: {
                                asyncChunks: false,
                                library: umdName ? {
                                    type: 'umd',
                                    name: umdName
                                } : {
                                    type: 'umd'
                                }
                            },
                            optimization: {
                                nodeEnv: process.env.NODE_ENV
                            },
                            plugins
                        }
                    }
                };
                return config;
            }
        case 'iife':
            {
                if (false === bundle) throw new Error('When using "iife" format, "bundle" must be set to "true". Since the default value for "bundle" is "true", so you can either explicitly set it to "true" or remove the field entirely.');
                const config = {
                    tools: {
                        rspack: {
                            module: {
                                parser: {
                                    javascript: {
                                        importMeta: false
                                    }
                                }
                            },
                            output: {
                                iife: true,
                                asyncChunks: false,
                                library: {
                                    type: 'modern-module'
                                }
                            },
                            optimization: {
                                nodeEnv: process.env.NODE_ENV
                            },
                            plugins
                        }
                    }
                };
                return config;
            }
        case 'mf':
            if (false === bundle) throw new Error('When using "mf" format, "bundle" must be set to "true". Since the default value for "bundle" is "true", so you can either explicitly set it to "true" or remove the field entirely.');
            return {
                dev: {
                    writeToDisk: true
                },
                tools: {
                    rspack: (config, { env })=>{
                        config.output = {
                            ...config.output,
                            uniqueName: pkgJson.name
                        };
                        config.optimization = {
                            ...config.optimization,
                            nodeEnv: 'development' === env ? 'development' : 'production',
                            moduleIds: 'development' === env ? 'named' : 'deterministic'
                        };
                    }
                },
                output: {
                    target: 'web'
                }
            };
        default:
            throw new Error(`Unsupported format: ${format}`);
    }
};
const disableUrlParseRsbuildPlugin = ()=>({
        name: 'rsbuild:disable-url-parse',
        setup (api) {
            api.modifyBundlerChain((config, { CHAIN_ID })=>{
                config.module.rule(CHAIN_ID.RULE.JS).parser({
                    url: false
                });
            });
        }
    });
const composeShimsConfig = (format, shims)=>{
    const resolvedShims = {
        cjs: {
            'import.meta.url': shims?.cjs?.['import.meta.url'] ?? true
        },
        esm: {
            __filename: shims?.esm?.__filename ?? false,
            __dirname: shims?.esm?.__dirname ?? false,
            require: shims?.esm?.require ?? false
        }
    };
    const enabledShims = {
        cjs: 'cjs' === format ? resolvedShims.cjs : {
            'import.meta.url': false
        },
        esm: 'esm' === format ? resolvedShims.esm : {
            __filename: false,
            __dirname: false,
            require: false
        }
    };
    let rsbuildConfig = {};
    switch(format){
        case 'esm':
            rsbuildConfig = {
                tools: {
                    rspack: {
                        node: {
                            __dirname: resolvedShims.esm.__dirname ? 'node-module' : false,
                            __filename: resolvedShims.esm.__filename ? 'node-module' : false
                        }
                    }
                },
                plugins: [
                    resolvedShims.esm.require && pluginEsmRequireShim(),
                    disableUrlParseRsbuildPlugin()
                ].filter(Boolean)
            };
            break;
        case 'cjs':
            rsbuildConfig = {
                plugins: [
                    resolvedShims.cjs['import.meta.url'] && pluginCjsImportMetaUrlShim(),
                    disableUrlParseRsbuildPlugin()
                ].filter(Boolean)
            };
            break;
        case 'umd':
        case 'iife':
        case 'mf':
            break;
        default:
            throw new Error(`Unsupported format: ${format}`);
    }
    return {
        rsbuildConfig,
        enabledShims
    };
};
const composeModuleImportWarn = (request, issuer)=>`The externalized commonjs request ${picocolors.green(`"${request}"`)} from ${picocolors.green(issuer)} will use ${picocolors.blue('"module"')} external type in ESM format. If you want to specify other external type, consider setting the request and type with ${picocolors.blue('"output.externals"')}.`;
const composeExternalsConfig = (format, externals)=>{
    const externalsTypeMap = {
        esm: 'module-import',
        cjs: 'commonjs-import',
        umd: 'umd',
        mf: 'global',
        iife: 'global'
    };
    const globalObjectMap = {
        esm: void 0,
        cjs: void 0,
        umd: void 0,
        mf: void 0,
        iife: 'globalThis'
    };
    const rspackConfig = {};
    const rsbuildConfig = {};
    switch(format){
        case 'esm':
        case 'cjs':
        case 'umd':
        case 'mf':
        case 'iife':
            rsbuildConfig.output = externals ? {
                externals
            } : {};
            rspackConfig.externalsType = externalsTypeMap[format];
            if (globalObjectMap[format]) rspackConfig.output = {
                globalObject: globalObjectMap[format]
            };
            break;
        default:
            throw new Error(`Unsupported format: ${format}`);
    }
    return {
        ...rsbuildConfig,
        tools: {
            rspack: rspackConfig
        }
    };
};
const composeAutoExtensionConfig = (config, format, autoExtension, pkgJson)=>{
    const { jsExtension, dtsExtension } = getDefaultExtension({
        format,
        pkgJson,
        autoExtension
    });
    const filenameHash = config.output?.filenameHash ?? false;
    const getHash = ()=>{
        if ('string' == typeof filenameHash) return filenameHash ? `.[${filenameHash}]` : '';
        return filenameHash ? '.[contenthash:8]' : '';
    };
    const hash = getHash();
    const defaultJsFilename = `[name]${hash}${jsExtension}`;
    const userJsFilename = config.output?.filename?.js;
    const finalJsExtension = 'string' == typeof userJsFilename && userJsFilename ? extname(userJsFilename) : jsExtension;
    const finalConfig = userJsFilename ? {} : {
        output: {
            filename: {
                js: defaultJsFilename
            }
        }
    };
    return {
        config: finalConfig,
        jsExtension: finalJsExtension,
        dtsExtension
    };
};
const composeSyntaxConfig = (target, syntax)=>{
    if (syntax) return {
        tools: {
            rspack: (config)=>{
                config.target = transformSyntaxToRspackTarget(syntax);
            }
        },
        output: {
            overrideBrowserslist: transformSyntaxToBrowserslist(syntax, target)
        }
    };
    return {
        tools: {
            rspack: (config)=>{
                config.target = [
                    'es2022'
                ];
                return config;
            }
        },
        output: {
            overrideBrowserslist: ESX_TO_BROWSERSLIST.esnext(target)
        }
    };
};
const traverseEntryQuery = (entry, callback)=>{
    const newEntry = {};
    for (const [key, value] of Object.entries(entry)){
        let result = value;
        result = 'string' == typeof value ? callback(value) : Array.isArray(value) ? value.map(callback) : {
            ...value,
            import: 'string' == typeof value.import ? callback(value.import) : value.import.map(callback)
        };
        newEntry[key] = result;
    }
    return newEntry;
};
const resolveEntryPath = (entries, root)=>traverseEntryQuery(entries, (item)=>node_path.resolve(root, item));
const composeEntryConfig = async (rawEntry, bundle, root, cssModulesAuto, userOutBase)=>{
    let entries = rawEntry;
    if (!entries) {
        if (false !== bundle) return {
            entryConfig: {},
            outBase: null
        };
        entries = {
            index: 'src/**'
        };
    }
    if ('object' != typeof entries) throw new Error(`The ${picocolors.cyan('source.entry')} configuration should be an object, but received ${typeof entries}: ${picocolors.cyan(entries)}. Checkout ${picocolors.green('https://rslib.rs/config/rsbuild/source#sourceentry')} for more details.`);
    if (false !== bundle) {
        const entryErrorReasons = [];
        traverseEntryQuery(entries, (entry)=>{
            const entryAbsPath = node_path.isAbsolute(entry) ? entry : node_path.resolve(root, entry);
            const isDirLike = '' === node_path.extname(entryAbsPath);
            const dirError = `Glob pattern ${picocolors.cyan(`"${entry}"`)} is not supported when "bundle" is "true", considering "bundle" to "false" to use bundleless mode, or specify a file entry to bundle. See ${picocolors.green('https://rslib.rs/guide/basic/output-structure')} for more details.`;
            if (node_fs.existsSync(entryAbsPath)) {
                const stats = node_fs.statSync(entryAbsPath);
                if (!stats.isFile()) entryErrorReasons.push(dirError);
            } else if (isDirLike) entryErrorReasons.push(dirError);
            else entryErrorReasons.push(`Can't resolve the entry ${picocolors.cyan(`"${entry}"`)} at the location ${picocolors.cyan(`${entryAbsPath}`)}. Please ensure that the file exists.`);
            return entry;
        });
        if (entryErrorReasons.length) throw new AggregateError(entryErrorReasons.map((reason)=>new Error(reason)));
        return {
            entryConfig: {
                source: {
                    entry: resolveEntryPath(entries, root)
                }
            },
            outBase: null
        };
    }
    const scanGlobEntries = async (tryResolveOutBase)=>{
        const resolvedEntries = {};
        const resolveOutBase = async (resolvedEntryFiles)=>{
            if (void 0 !== userOutBase) return node_path.isAbsolute(userOutBase) ? userOutBase : node_path.resolve(root, userOutBase);
            const lcp = await calcLongestCommonPath(resolvedEntryFiles) ?? root;
            return lcp;
        };
        for (const key of Object.keys(entries)){
            const entry = entries[key];
            const entryFiles = Array.isArray(entry) ? entry : 'string' == typeof entry ? [
                entry
            ] : null;
            if (!entryFiles) throw new Error('Entry can only be a string or an array of strings for now');
            const globEntryFiles = await glob(entryFiles, {
                cwd: root,
                absolute: true
            });
            const resolvedEntryFiles = globEntryFiles.filter((i)=>!DTS_EXTENSIONS_PATTERN.test(i));
            if (0 === resolvedEntryFiles.length) throw new Error(`Cannot find ${resolvedEntryFiles}`);
            const outBase = await resolveOutBase(resolvedEntryFiles);
            function getEntryName(file) {
                const { dir, name } = node_path.parse(node_path.relative(outBase, file));
                const entryFileName = node_path.join(dir, name);
                if (isCssGlobalFile(file, cssModulesAuto)) return `${RSLIB_CSS_ENTRY_FLAG}/${entryFileName}`;
                return entryFileName;
            }
            for (const file of resolvedEntryFiles){
                const entryName = getEntryName(file);
                if (resolvedEntries[entryName]) tryResolveOutBase && logger.warn(`Duplicate entry ${picocolors.cyan(entryName)} from ${picocolors.cyan(node_path.relative(root, file))} and ${picocolors.cyan(node_path.relative(root, resolvedEntries[entryName]))}, which may lead to the incorrect output, please rename the file.`);
                resolvedEntries[entryName] = file;
            }
        }
        if (tryResolveOutBase) {
            const outBase = await resolveOutBase(Object.values(resolvedEntries));
            return {
                resolvedEntries,
                outBase
            };
        }
        return {
            resolvedEntries,
            outBase: null
        };
    };
    const { outBase } = await scanGlobEntries(true);
    const entryConfig = {
        tools: {
            rspack: {
                entry: async ()=>{
                    const { resolvedEntries } = await scanGlobEntries(false);
                    return resolvedEntries;
                }
            }
        }
    };
    return {
        entryConfig,
        outBase
    };
};
const composeBundlelessExternalConfig = (jsExtension, redirect, cssModulesAuto, bundle, outBase)=>{
    if (bundle) return {
        config: {}
    };
    const styleRedirectPath = redirect.style?.path ?? true;
    const styleRedirectExtension = redirect.style?.extension ?? true;
    const jsRedirectPath = redirect.js?.path ?? true;
    const jsRedirectExtension = redirect.js?.extension ?? true;
    const assetRedirectPath = redirect.asset?.path ?? true;
    const assetRedirectExtension = redirect.asset?.extension ?? true;
    let resolver;
    return {
        resolvedJsRedirect: {
            path: jsRedirectPath,
            extension: jsRedirectExtension
        },
        config: {
            output: {
                externals: [
                    async (data, callback)=>{
                        const { request, getResolve, context, contextInfo } = data;
                        if (!request || !getResolve || !context || !contextInfo) return callback();
                        const { issuer } = contextInfo;
                        if (!resolver) resolver = await getResolve();
                        async function redirectPath(request) {
                            try {
                                let resolvedRequest = request;
                                resolvedRequest = await resolver(context, resolvedRequest);
                                if ('string' != typeof outBase) throw new Error(`outBase expect to be a string in bundleless mode, but got ${outBase}`);
                                const isSubpath = normalizeSlash(resolvedRequest).startsWith(`${normalizeSlash(outBase)}/`);
                                if (isSubpath) {
                                    resolvedRequest = normalizeSlash(node_path.relative(node_path.dirname(issuer), resolvedRequest));
                                    if ('.' !== resolvedRequest[0]) resolvedRequest = `./${resolvedRequest}`;
                                    return resolvedRequest;
                                }
                                return;
                            } catch (_e) {
                                logger.debug(`Failed to resolve module ${picocolors.green(`"${request}"`)} from ${picocolors.green(issuer)}. If it's an npm package, consider adding it to dependencies or peerDependencies in package.json to make it externalized.`);
                                return request;
                            }
                        }
                        if (issuer) {
                            let resolvedRequest = request;
                            const redirectedPath = await redirectPath(resolvedRequest);
                            const cssExternal = await cssExternalHandler(resolvedRequest, callback, jsExtension, cssModulesAuto, styleRedirectPath, styleRedirectExtension, redirectedPath, issuer);
                            if (false !== cssExternal) return cssExternal;
                            if (void 0 === redirectedPath) return callback(void 0, request);
                            if (jsRedirectPath) resolvedRequest = redirectedPath;
                            if (resolvedRequest.startsWith('.')) {
                                const ext = extname(resolvedRequest);
                                if (ext) if (JS_EXTENSIONS_PATTERN.test(resolvedRequest)) {
                                    if (jsRedirectExtension) resolvedRequest = resolvedRequest.replace(/\.[^.]+$/, jsExtension);
                                } else {
                                    resolvedRequest = assetRedirectPath ? redirectedPath : request;
                                    if (assetRedirectExtension) resolvedRequest = resolvedRequest.replace(/\.[^.]+$/, jsExtension);
                                }
                                else if (jsRedirectExtension) resolvedRequest = `${resolvedRequest}${jsExtension}`;
                            }
                            return callback(void 0, resolvedRequest);
                        }
                        callback();
                    }
                ]
            }
        }
    };
};
const composeDtsConfig = async (libConfig, format, dtsExtension)=>{
    const { autoExternal, banner, footer, redirect } = libConfig;
    let { dts } = libConfig;
    if (false === dts || void 0 === dts) return {};
    if (true === dts) dts = {
        bundle: false
    };
    const { pluginDts } = await import("rsbuild-plugin-dts");
    return {
        plugins: [
            pluginDts({
                bundle: dts?.bundle,
                distPath: dts?.distPath,
                build: dts?.build,
                abortOnError: dts?.abortOnError,
                dtsExtension: dts?.autoExtension ? dtsExtension : '.d.ts',
                autoExternal: getAutoExternalDefaultValue(format, autoExternal),
                banner: banner?.dts,
                footer: footer?.dts,
                redirect: redirect?.dts
            })
        ]
    };
};
const composeTargetConfig = (userTarget, format)=>{
    const target = userTarget ?? ('mf' === format ? 'web' : 'node');
    switch(target){
        case 'web':
            return {
                config: {
                    tools: {
                        rspack: {
                            target: [
                                'web'
                            ]
                        }
                    }
                },
                target: 'web',
                externalsConfig: {}
            };
        case 'node':
            return {
                config: {
                    tools: {
                        rspack: {
                            target: [
                                'node'
                            ]
                        }
                    },
                    output: {
                        target: 'node'
                    }
                },
                target: 'node',
                externalsConfig: {
                    output: {
                        externals: nodeBuiltInModules
                    }
                }
            };
        default:
            throw new Error(`Unsupported platform: ${target}`);
    }
};
const composeExternalHelpersConfig = (externalHelpers, pkgJson)=>{
    let defaultConfig = {
        tools: {
            swc: {
                jsc: {
                    externalHelpers: false
                }
            }
        }
    };
    if (externalHelpers) {
        const deps = [
            ...Object.keys(pkgJson?.dependencies ?? []),
            ...Object.keys(pkgJson?.devDependencies ?? [])
        ];
        if (!deps.includes(SWC_HELPERS)) {
            logger.error(`${picocolors.green('externalHelpers')} is enabled, but the ${picocolors.blue(SWC_HELPERS)} dependency declaration was not found in package.json.`);
            process.exit(1);
        }
        defaultConfig = Object.assign(defaultConfig, {
            output: {
                externals: new RegExp(`^${SWC_HELPERS}($|\\/|\\\\)`)
            }
        });
        defaultConfig.tools.swc.jsc.externalHelpers = true;
    }
    return defaultConfig;
};
async function composeLibRsbuildConfig(config, root, sharedPlugins) {
    checkMFPlugin(config, sharedPlugins);
    const rootPath = root ? getAbsolutePath(process.cwd(), root) : process.cwd();
    const pkgJson = readPackageJson(rootPath);
    const { compilerOptions } = await loadTsconfig(rootPath, config.source?.tsconfigPath);
    const cssModulesAuto = config.output?.cssModules?.auto ?? true;
    const { format = 'esm', shims, bundle = true, banner = {}, footer = {}, autoExtension = true, autoExternal, externalHelpers = false, redirect = {}, umdName } = config;
    const { rsbuildConfig: shimsConfig, enabledShims } = composeShimsConfig(format, shims);
    const formatConfig = composeFormatConfig({
        format,
        pkgJson: pkgJson,
        bundle,
        umdName
    });
    const externalHelpersConfig = composeExternalHelpersConfig(externalHelpers, pkgJson);
    const userExternalsConfig = composeExternalsConfig(format, config.output?.externals);
    const { config: autoExtensionConfig, jsExtension, dtsExtension } = composeAutoExtensionConfig(config, format, autoExtension, pkgJson);
    const { entryConfig, outBase } = await composeEntryConfig(config.source?.entry, config.bundle, rootPath, cssModulesAuto, config.outBase);
    const { config: bundlelessExternalConfig } = composeBundlelessExternalConfig(jsExtension, redirect, cssModulesAuto, bundle, outBase);
    const { config: targetConfig, externalsConfig: targetExternalsConfig, target } = composeTargetConfig(config.output?.target, format);
    const syntaxConfig = composeSyntaxConfig(target, config?.syntax);
    const autoExternalConfig = composeAutoExternalConfig({
        bundle,
        format,
        autoExternal,
        pkgJson,
        userExternals: config.output?.externals
    });
    const cssConfig = composeCssConfig(outBase, cssModulesAuto, config.bundle, banner?.css, footer?.css);
    const assetConfig = composeAssetConfig(bundle, format);
    const entryChunkConfig = composeEntryChunkConfig({
        enabledImportMetaUrlShim: enabledShims.cjs['import.meta.url'],
        contextToWatch: outBase
    });
    const dtsConfig = await composeDtsConfig(config, format, dtsExtension);
    const externalsWarnConfig = composeExternalsWarnConfig(format, userExternalsConfig?.output?.externals, autoExternalConfig?.output?.externals);
    const minifyConfig = composeMinifyConfig(config);
    const bannerFooterConfig = composeBannerFooterConfig(banner, footer);
    const decoratorsConfig = composeDecoratorsConfig(compilerOptions, config.source?.decorators?.version);
    return (0, __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.mergeRsbuildConfig)(formatConfig, shimsConfig, syntaxConfig, externalHelpersConfig, autoExtensionConfig, targetConfig, externalsWarnConfig, userExternalsConfig, autoExternalConfig, targetExternalsConfig, bundlelessExternalConfig, entryConfig, cssConfig, assetConfig, entryChunkConfig, minifyConfig, dtsConfig, bannerFooterConfig, decoratorsConfig);
}
async function composeCreateRsbuildConfig(rslibConfig) {
    const constantRsbuildConfig = await createConstantRsbuildConfig();
    const { lib: libConfigsArray, mode: _mode, root, plugins: sharedPlugins, dev: _dev, server: _server, ...sharedRsbuildConfig } = rslibConfig;
    if (!Array.isArray(libConfigsArray) || 0 === libConfigsArray.length) throw new Error(`Expect "lib" field to be a non-empty array, but got: ${picocolors.cyan(JSON.stringify(libConfigsArray))}.`);
    const libConfigPromises = libConfigsArray.map(async (libConfig)=>{
        const userConfig = (0, __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.mergeRsbuildConfig)(sharedRsbuildConfig, libConfig);
        const libRsbuildConfig = await composeLibRsbuildConfig(userConfig, root, sharedPlugins);
        userConfig.source ??= {};
        userConfig.source.entry = {};
        userConfig.output ??= {};
        delete userConfig.output.externals;
        const config = {
            format: libConfig.format ?? 'esm',
            config: (0, __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.mergeRsbuildConfig)(constantRsbuildConfig, libRsbuildConfig, omit(userConfig, {
                id: true,
                bundle: true,
                format: true,
                autoExtension: true,
                autoExternal: true,
                redirect: true,
                syntax: true,
                externalHelpers: true,
                banner: true,
                footer: true,
                dts: true,
                shims: true,
                umdName: true,
                outBase: true
            }))
        };
        if ('string' == typeof libConfig.id) config.id = libConfig.id;
        return config;
    });
    const composedRsbuildConfig = await Promise.all(libConfigPromises);
    return composedRsbuildConfig;
}
async function composeRsbuildEnvironments(rslibConfig) {
    const rsbuildConfigWithLibInfo = await composeCreateRsbuildConfig(rslibConfig);
    const environmentWithInfos = [];
    const usedIds = rsbuildConfigWithLibInfo.map(({ id })=>id).filter(Boolean);
    const environments = {};
    const formatCount = rsbuildConfigWithLibInfo.reduce((acc, { format })=>{
        acc[format] = (acc[format] ?? 0) + 1;
        return acc;
    }, {});
    const composeDefaultId = (format)=>{
        const nextDefaultId = (format, index)=>`${format}${1 === formatCount[format] && 0 === index ? '' : index}`;
        let index = 0;
        let candidateId = nextDefaultId(format, index);
        while(-1 !== usedIds.indexOf(candidateId))candidateId = nextDefaultId(format, ++index);
        usedIds.push(candidateId);
        return candidateId;
    };
    for (const { format, id, config } of rsbuildConfigWithLibInfo){
        const libId = 'string' == typeof id ? id : composeDefaultId(format);
        environments[libId] = config;
        environmentWithInfos.push({
            id: libId,
            format,
            config
        });
    }
    const conflictIds = usedIds.filter((id, index)=>usedIds.indexOf(id) !== index);
    if (conflictIds.length) throw new Error(`The following ids are duplicated: ${conflictIds.map((id)=>`"${id}"`).join(', ')}. Please change the "lib.id" to be unique.`);
    return {
        environments,
        environmentWithInfos
    };
}
const pruneEnvironments = (environments, libs)=>{
    if (!libs || 0 === libs.length) return environments;
    const filteredEnvironments = Object.fromEntries(Object.entries(environments).filter(([name])=>libs.includes(name)));
    if (0 === Object.keys(filteredEnvironments).length) throw new Error(`The following libs are not found: ${libs.map((lib)=>`"${lib}"`).join(', ')}.`);
    return filteredEnvironments;
};
async function watchFilesForRestart(files, restart) {
    if (!files.length) return;
    const chokidar = await import("../compiled/chokidar/index.js");
    const watcher = chokidar.watch(files, {
        ignoreInitial: true,
        ignorePermissionErrors: true
    });
    const callback = debounce(async (filePath)=>{
        watcher.close();
        await beforeRestart({
            filePath
        });
        await restart();
    }, 300);
    watcher.on('add', callback);
    watcher.on('change', callback);
    watcher.on('unlink', callback);
}
let cleaners = [];
const onBeforeRestart = (cleaner)=>{
    cleaners.push(cleaner);
};
const clearConsole = ()=>{
    if (isTTY() && !process.env.DEBUG) process.stdout.write('\x1B[H\x1B[2J');
};
const beforeRestart = async ({ filePath, clear = true } = {})=>{
    if (clear) clearConsole();
    if (filePath) {
        const filename = node_path.basename(filePath);
        logger.info(`restart because ${picocolors.yellow(filename)} is changed.\n`);
    } else logger.info('restarting...\n');
    for (const cleaner of cleaners)await cleaner();
    cleaners = [];
};
async function build(config, options = {}) {
    const { environments } = await composeRsbuildEnvironments(config);
    const rsbuildInstance = await (0, __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.createRsbuild)({
        callerName: 'rslib',
        rsbuildConfig: {
            mode: 'production',
            root: config.root,
            plugins: config.plugins,
            dev: config.dev,
            server: config.server,
            environments: pruneEnvironments(environments, options.lib)
        }
    });
    const buildInstance = await rsbuildInstance.build({
        watch: options.watch
    });
    if (options.watch) onBeforeRestart(buildInstance.close);
    else await buildInstance.close();
    return rsbuildInstance;
}
function toArr(any) {
    return null == any ? [] : Array.isArray(any) ? any : [
        any
    ];
}
function toVal(out, key, val, opts) {
    var x, old = out[key], nxt = ~opts.string.indexOf(key) ? null == val || true === val ? '' : String(val) : 'boolean' == typeof val ? val : ~opts.boolean.indexOf(key) ? 'false' === val ? false : 'true' === val || (out._.push((x = +val, 0 * x === 0) ? x : val), !!val) : (x = +val, 0 * x === 0) ? x : val;
    out[key] = null == old ? nxt : Array.isArray(old) ? old.concat(nxt) : [
        old,
        nxt
    ];
}
function mri2(args, opts) {
    args = args || [];
    opts = opts || {};
    var k, arr, arg, name, val, out = {
        _: []
    };
    var i = 0, j = 0, idx = 0, len = args.length;
    const alibi = void 0 !== opts.alias;
    const strict = void 0 !== opts.unknown;
    const defaults = void 0 !== opts.default;
    opts.alias = opts.alias || {};
    opts.string = toArr(opts.string);
    opts.boolean = toArr(opts.boolean);
    if (alibi) for(k in opts.alias){
        arr = opts.alias[k] = toArr(opts.alias[k]);
        for(i = 0; i < arr.length; i++)(opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);
    }
    for(i = opts.boolean.length; i-- > 0;){
        arr = opts.alias[opts.boolean[i]] || [];
        for(j = arr.length; j-- > 0;)opts.boolean.push(arr[j]);
    }
    for(i = opts.string.length; i-- > 0;){
        arr = opts.alias[opts.string[i]] || [];
        for(j = arr.length; j-- > 0;)opts.string.push(arr[j]);
    }
    if (defaults) for(k in opts.default){
        name = typeof opts.default[k];
        arr = opts.alias[k] = opts.alias[k] || [];
        if (void 0 !== opts[name]) {
            opts[name].push(k);
            for(i = 0; i < arr.length; i++)opts[name].push(arr[i]);
        }
    }
    const keys = strict ? Object.keys(opts.alias) : [];
    for(i = 0; i < len; i++){
        arg = args[i];
        if ('--' === arg) {
            out._ = out._.concat(args.slice(++i));
            break;
        }
        for(j = 0; j < arg.length && 45 === arg.charCodeAt(j); j++);
        if (0 === j) out._.push(arg);
        else if ('no-' === arg.substring(j, j + 3)) {
            name = arg.substring(j + 3);
            if (strict && !~keys.indexOf(name)) return opts.unknown(arg);
            out[name] = false;
        } else {
            for(idx = j + 1; idx < arg.length && 61 !== arg.charCodeAt(idx); idx++);
            name = arg.substring(j, idx);
            val = arg.substring(++idx) || i + 1 === len || 45 === ('' + args[i + 1]).charCodeAt(0) || args[++i];
            arr = 2 === j ? [
                name
            ] : name;
            for(idx = 0; idx < arr.length; idx++){
                name = arr[idx];
                if (strict && !~keys.indexOf(name)) return opts.unknown('-'.repeat(j) + name);
                toVal(out, name, idx + 1 < arr.length || val, opts);
            }
        }
    }
    if (defaults) {
        for(k in opts.default)if (void 0 === out[k]) out[k] = opts.default[k];
    }
    if (alibi) for(k in out){
        arr = opts.alias[k] || [];
        while(arr.length > 0)out[arr.shift()] = out[k];
    }
    return out;
}
const removeBrackets = (v)=>v.replace(/[<[].+/, "").trim();
const findAllBrackets = (v)=>{
    const ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g;
    const SQUARE_BRACKET_RE_GLOBAL = /\[([^\]]+)\]/g;
    const res = [];
    const parse = (match)=>{
        let variadic = false;
        let value = match[1];
        if (value.startsWith("...")) {
            value = value.slice(3);
            variadic = true;
        }
        return {
            required: match[0].startsWith("<"),
            value,
            variadic
        };
    };
    let angledMatch;
    while(angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v))res.push(parse(angledMatch));
    let squareMatch;
    while(squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v))res.push(parse(squareMatch));
    return res;
};
const getMriOptions = (options)=>{
    const result = {
        alias: {},
        boolean: []
    };
    for (const [index, option] of options.entries()){
        if (option.names.length > 1) result.alias[option.names[0]] = option.names.slice(1);
        if (option.isBoolean) if (option.negated) {
            const hasStringTypeOption = options.some((o, i)=>i !== index && o.names.some((name)=>option.names.includes(name)) && "boolean" == typeof o.required);
            if (!hasStringTypeOption) result.boolean.push(option.names[0]);
        } else result.boolean.push(option.names[0]);
    }
    return result;
};
const findLongest = (arr)=>arr.sort((a, b)=>a.length > b.length ? -1 : 1)[0];
const padRight = (str, length)=>str.length >= length ? str : `${str}${" ".repeat(length - str.length)}`;
const camelcase = (input)=>input.replace(/([a-z])-([a-z])/g, (_, p1, p2)=>p1 + p2.toUpperCase());
const setDotProp = (obj, keys, val)=>{
    let i = 0;
    let length = keys.length;
    let t = obj;
    let x;
    for(; i < length; ++i){
        x = t[keys[i]];
        t = t[keys[i]] = i === length - 1 ? val : null != x ? x : !~keys[i + 1].indexOf(".") && +keys[i + 1] > -1 ? [] : {};
    }
};
const setByType = (obj, transforms)=>{
    for (const key of Object.keys(transforms)){
        const transform = transforms[key];
        if (transform.shouldTransform) {
            obj[key] = Array.prototype.concat.call([], obj[key]);
            if ("function" == typeof transform.transformFunction) obj[key] = obj[key].map(transform.transformFunction);
        }
    }
};
const getFileName = (input)=>{
    const m = /([^\\\/]+)$/.exec(input);
    return m ? m[1] : "";
};
const camelcaseOptionName = (name)=>name.split(".").map((v, i)=>0 === i ? camelcase(v) : v).join(".");
class CACError extends Error {
    constructor(message){
        super(message);
        this.name = this.constructor.name;
        if ("function" == typeof Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
        else this.stack = new Error(message).stack;
    }
}
class Option {
    constructor(rawName, description, config){
        this.rawName = rawName;
        this.description = description;
        this.config = Object.assign({}, config);
        rawName = rawName.replace(/\.\*/g, "");
        this.negated = false;
        this.names = removeBrackets(rawName).split(",").map((v)=>{
            let name = v.trim().replace(/^-{1,2}/, "");
            if (name.startsWith("no-")) {
                this.negated = true;
                name = name.replace(/^no-/, "");
            }
            return camelcaseOptionName(name);
        }).sort((a, b)=>a.length > b.length ? 1 : -1);
        this.name = this.names[this.names.length - 1];
        if (this.negated && null == this.config.default) this.config.default = true;
        if (rawName.includes("<")) this.required = true;
        else if (rawName.includes("[")) this.required = false;
        else this.isBoolean = true;
    }
}
const processArgs = process.argv;
const platformInfo = `${process.platform}-${process.arch} node-${process.version}`;
class Command {
    constructor(rawName, description, config = {}, cli){
        this.rawName = rawName;
        this.description = description;
        this.config = config;
        this.cli = cli;
        this.options = [];
        this.aliasNames = [];
        this.name = removeBrackets(rawName);
        this.args = findAllBrackets(rawName);
        this.examples = [];
    }
    usage(text) {
        this.usageText = text;
        return this;
    }
    allowUnknownOptions() {
        this.config.allowUnknownOptions = true;
        return this;
    }
    ignoreOptionDefaultValue() {
        this.config.ignoreOptionDefaultValue = true;
        return this;
    }
    version(version, customFlags = "-v, --version") {
        this.versionNumber = version;
        this.option(customFlags, "Display version number");
        return this;
    }
    example(example) {
        this.examples.push(example);
        return this;
    }
    option(rawName, description, config) {
        const option = new Option(rawName, description, config);
        this.options.push(option);
        return this;
    }
    alias(name) {
        this.aliasNames.push(name);
        return this;
    }
    action(callback) {
        this.commandAction = callback;
        return this;
    }
    isMatched(name) {
        return this.name === name || this.aliasNames.includes(name);
    }
    get isDefaultCommand() {
        return "" === this.name || this.aliasNames.includes("!");
    }
    get isGlobalCommand() {
        return this instanceof GlobalCommand;
    }
    hasOption(name) {
        name = name.split(".")[0];
        return this.options.find((option)=>option.names.includes(name));
    }
    outputHelp() {
        const { name, commands } = this.cli;
        const { versionNumber, options: globalOptions, helpCallback } = this.cli.globalCommand;
        let sections = [
            {
                body: `${name}${versionNumber ? `/${versionNumber}` : ""}`
            }
        ];
        sections.push({
            title: "Usage",
            body: `  $ ${name} ${this.usageText || this.rawName}`
        });
        const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;
        if (showCommands) {
            const longestCommandName = findLongest(commands.map((command)=>command.rawName));
            sections.push({
                title: "Commands",
                body: commands.map((command)=>`  ${padRight(command.rawName, longestCommandName.length)}  ${command.description}`).join("\n")
            });
            sections.push({
                title: "For more info, run any command with the `--help` flag",
                body: commands.map((command)=>`  $ ${name}${"" === command.name ? "" : ` ${command.name}`} --help`).join("\n")
            });
        }
        let options = this.isGlobalCommand ? globalOptions : [
            ...this.options,
            ...globalOptions || []
        ];
        if (!this.isGlobalCommand && !this.isDefaultCommand) options = options.filter((option)=>"version" !== option.name);
        if (options.length > 0) {
            const longestOptionName = findLongest(options.map((option)=>option.rawName));
            sections.push({
                title: "Options",
                body: options.map((option)=>`  ${padRight(option.rawName, longestOptionName.length)}  ${option.description} ${void 0 === option.config.default ? "" : `(default: ${option.config.default})`}`).join("\n")
            });
        }
        if (this.examples.length > 0) sections.push({
            title: "Examples",
            body: this.examples.map((example)=>{
                if ("function" == typeof example) return example(name);
                return example;
            }).join("\n")
        });
        if (helpCallback) sections = helpCallback(sections) || sections;
        console.log(sections.map((section)=>section.title ? `${section.title}:
${section.body}` : section.body).join("\n\n"));
    }
    outputVersion() {
        const { name } = this.cli;
        const { versionNumber } = this.cli.globalCommand;
        if (versionNumber) console.log(`${name}/${versionNumber} ${platformInfo}`);
    }
    checkRequiredArgs() {
        const minimalArgsCount = this.args.filter((arg)=>arg.required).length;
        if (this.cli.args.length < minimalArgsCount) throw new CACError(`missing required args for command \`${this.rawName}\``);
    }
    checkUnknownOptions() {
        const { options, globalCommand } = this.cli;
        if (!this.config.allowUnknownOptions) {
            for (const name of Object.keys(options))if ("--" !== name && !this.hasOption(name) && !globalCommand.hasOption(name)) throw new CACError(`Unknown option \`${name.length > 1 ? `--${name}` : `-${name}`}\``);
        }
    }
    checkOptionValue() {
        const { options: parsedOptions, globalCommand } = this.cli;
        const options = [
            ...globalCommand.options,
            ...this.options
        ];
        for (const option of options){
            const value = parsedOptions[option.name.split(".")[0]];
            if (option.required) {
                const hasNegated = options.some((o)=>o.negated && o.names.includes(option.name));
                if (true === value || false === value && !hasNegated) throw new CACError(`option \`${option.rawName}\` value is missing`);
            }
        }
    }
}
class GlobalCommand extends Command {
    constructor(cli){
        super("@@global@@", "", {}, cli);
    }
}
var __assign = Object.assign;
class CAC extends EventEmitter {
    constructor(name = ""){
        super();
        this.name = name;
        this.commands = [];
        this.rawArgs = [];
        this.args = [];
        this.options = {};
        this.globalCommand = new GlobalCommand(this);
        this.globalCommand.usage("<command> [options]");
    }
    usage(text) {
        this.globalCommand.usage(text);
        return this;
    }
    command(rawName, description, config) {
        const command = new Command(rawName, description || "", config, this);
        command.globalCommand = this.globalCommand;
        this.commands.push(command);
        return command;
    }
    option(rawName, description, config) {
        this.globalCommand.option(rawName, description, config);
        return this;
    }
    help(callback) {
        this.globalCommand.option("-h, --help", "Display this message");
        this.globalCommand.helpCallback = callback;
        this.showHelpOnExit = true;
        return this;
    }
    version(version, customFlags = "-v, --version") {
        this.globalCommand.version(version, customFlags);
        this.showVersionOnExit = true;
        return this;
    }
    example(example) {
        this.globalCommand.example(example);
        return this;
    }
    outputHelp() {
        if (this.matchedCommand) this.matchedCommand.outputHelp();
        else this.globalCommand.outputHelp();
    }
    outputVersion() {
        this.globalCommand.outputVersion();
    }
    setParsedInfo({ args, options }, matchedCommand, matchedCommandName) {
        this.args = args;
        this.options = options;
        if (matchedCommand) this.matchedCommand = matchedCommand;
        if (matchedCommandName) this.matchedCommandName = matchedCommandName;
        return this;
    }
    unsetMatchedCommand() {
        this.matchedCommand = void 0;
        this.matchedCommandName = void 0;
    }
    parse(argv = processArgs, { run = true } = {}) {
        this.rawArgs = argv;
        if (!this.name) this.name = argv[1] ? getFileName(argv[1]) : "cli";
        let shouldParse = true;
        for (const command of this.commands){
            const parsed = this.mri(argv.slice(2), command);
            const commandName = parsed.args[0];
            if (command.isMatched(commandName)) {
                shouldParse = false;
                const parsedInfo = __assign(__assign({}, parsed), {
                    args: parsed.args.slice(1)
                });
                this.setParsedInfo(parsedInfo, command, commandName);
                this.emit(`command:${commandName}`, command);
            }
        }
        if (shouldParse) {
            for (const command of this.commands)if ("" === command.name) {
                shouldParse = false;
                const parsed = this.mri(argv.slice(2), command);
                this.setParsedInfo(parsed, command);
                this.emit("command:!", command);
            }
        }
        if (shouldParse) {
            const parsed = this.mri(argv.slice(2));
            this.setParsedInfo(parsed);
        }
        if (this.options.help && this.showHelpOnExit) {
            this.outputHelp();
            run = false;
            this.unsetMatchedCommand();
        }
        if (this.options.version && this.showVersionOnExit && null == this.matchedCommandName) {
            this.outputVersion();
            run = false;
            this.unsetMatchedCommand();
        }
        const parsedArgv = {
            args: this.args,
            options: this.options
        };
        if (run) this.runMatchedCommand();
        if (!this.matchedCommand && this.args[0]) this.emit("command:*");
        return parsedArgv;
    }
    mri(argv, command) {
        const cliOptions = [
            ...this.globalCommand.options,
            ...command ? command.options : []
        ];
        const mriOptions = getMriOptions(cliOptions);
        let argsAfterDoubleDashes = [];
        const doubleDashesIndex = argv.indexOf("--");
        if (doubleDashesIndex > -1) {
            argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);
            argv = argv.slice(0, doubleDashesIndex);
        }
        let parsed = mri2(argv, mriOptions);
        parsed = Object.keys(parsed).reduce((res, name)=>__assign(__assign({}, res), {
                [camelcaseOptionName(name)]: parsed[name]
            }), {
            _: []
        });
        const args = parsed._;
        const options = {
            "--": argsAfterDoubleDashes
        };
        const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;
        let transforms = Object.create(null);
        for (const cliOption of cliOptions){
            if (!ignoreDefault && void 0 !== cliOption.config.default) for (const name of cliOption.names)options[name] = cliOption.config.default;
            if (Array.isArray(cliOption.config.type)) {
                if (void 0 === transforms[cliOption.name]) {
                    transforms[cliOption.name] = Object.create(null);
                    transforms[cliOption.name]["shouldTransform"] = true;
                    transforms[cliOption.name]["transformFunction"] = cliOption.config.type[0];
                }
            }
        }
        for (const key of Object.keys(parsed))if ("_" !== key) {
            const keys = key.split(".");
            setDotProp(options, keys, parsed[key]);
            setByType(options, transforms);
        }
        return {
            args,
            options
        };
    }
    runMatchedCommand() {
        const { args, options, matchedCommand: command } = this;
        if (!command || !command.commandAction) return;
        command.checkUnknownOptions();
        command.checkOptionValue();
        command.checkRequiredArgs();
        const actionArgs = [];
        command.args.forEach((arg, index)=>{
            if (arg.variadic) actionArgs.push(args.slice(index));
            else actionArgs.push(args[index]);
        });
        actionArgs.push(options);
        return command.commandAction.apply(this, actionArgs);
    }
}
const cac = (name = "")=>new CAC(name);
const dist = cac;
const getEnvDir = (cwd, envDir)=>{
    if (envDir) return node_path.isAbsolute(envDir) ? envDir : node_path.resolve(cwd, envDir);
    return cwd;
};
async function init(options) {
    const cwd = process.cwd();
    const root = options.root ? getAbsolutePath(cwd, options.root) : cwd;
    const envs = (0, __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.loadEnv)({
        cwd: getEnvDir(root, options.envDir),
        mode: options.envMode
    });
    onBeforeRestart(envs.cleanup);
    const { content: config, filePath: configFilePath } = await loadConfig({
        cwd: root,
        path: options.config,
        envMode: options.envMode
    });
    config.source ||= {};
    config.source.define = {
        ...envs.publicVars,
        ...config.source.define
    };
    if (options.root) config.root = root;
    return {
        config,
        configFilePath,
        watchFiles: [
            configFilePath,
            ...envs.filePaths
        ]
    };
}
async function inspect(config, options = {}) {
    const { environments } = await composeRsbuildEnvironments(config);
    const rsbuildInstance = await (0, __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.createRsbuild)({
        callerName: 'rslib',
        rsbuildConfig: {
            mode: 'production',
            root: config.root,
            plugins: config.plugins,
            dev: config.dev,
            server: config.server,
            environments: pruneEnvironments(environments, options.lib)
        }
    });
    await rsbuildInstance.inspectConfig({
        mode: options.mode,
        verbose: options.verbose,
        outputPath: options.output,
        writeToDisk: true
    });
    return rsbuildInstance;
}
async function startMFDevServer(config, options = {}) {
    const rsbuildInstance = await initMFRsbuild(config, options);
    return rsbuildInstance;
}
async function initMFRsbuild(config, options = {}) {
    const { environments, environmentWithInfos } = await composeRsbuildEnvironments(config);
    const selectedEnvironmentIds = environmentWithInfos.filter((env)=>{
        const isMf = 'mf' === env.format;
        if (!options?.lib || 0 === options.lib.length) return isMf;
        return env.id && options.lib.includes(env.id);
    }).map((env)=>env.id);
    if (!selectedEnvironmentIds.length) throw new Error(`No mf format found in ${options.lib ? `libs ${options.lib.map((lib)=>`"${lib}"`).join(', ')}` : 'your config'}, please check your config to ensure that the mf format is enabled correctly.`);
    const selectedEnvironments = pruneEnvironments(environments, selectedEnvironmentIds);
    const rsbuildInstance = await (0, __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.createRsbuild)({
        callerName: 'rslib',
        rsbuildConfig: {
            mode: 'development',
            root: config.root,
            plugins: config.plugins,
            dev: config.dev,
            server: config.server,
            environments: selectedEnvironments
        }
    });
    const devServer = await rsbuildInstance.startDevServer();
    onBeforeRestart(devServer.server.close);
    return rsbuildInstance;
}
const applyCommonOptions = (cli)=>{
    cli.option('-c, --config <config>', 'specify the configuration file, can be a relative or absolute path').option('-r, --root <root>', 'specify the project root directory, can be an absolute path or a path relative to cwd').option('--env-mode <mode>', 'specify the env mode to load the `.env.[mode]` file').option('--env-dir <dir>', 'specify the directory to load `.env` files').option('--lib <id>', 'specify the library (repeatable, e.g. --lib esm --lib cjs)', {
        type: [
            String
        ],
        default: []
    });
};
function runCli() {
    const cli = dist('rslib');
    cli.help();
    cli.version("0.11.0");
    applyCommonOptions(cli);
    const buildCommand = cli.command('build', 'build the library for production');
    const inspectCommand = cli.command('inspect', 'inspect the Rsbuild / Rspack configs of Rslib projects');
    const mfDevCommand = cli.command('mf-dev', 'start Rsbuild dev server of Module Federation format');
    buildCommand.option('-w, --watch', 'turn on watch mode, watch for changes and rebuild').action(async (options)=>{
        try {
            const cliBuild = async ()=>{
                const { config, watchFiles } = await init(options);
                await build(config, options);
                if (options.watch) watchFilesForRestart(watchFiles, async ()=>{
                    await cliBuild();
                });
            };
            await cliBuild();
        } catch (err) {
            logger.error('Failed to build.');
            if (err instanceof AggregateError) for (const error of err.errors)logger.error(error);
            else logger.error(err);
            process.exit(1);
        }
    });
    inspectCommand.option('--output <output>', 'specify inspect content output path', {
        default: '.rsbuild'
    }).option('--verbose', 'show full function definitions in output').action(async (options)=>{
        try {
            const { config } = await init(options);
            await inspect(config, {
                lib: options.lib,
                mode: options.mode,
                output: options.output,
                verbose: options.verbose
            });
        } catch (err) {
            logger.error('Failed to inspect config.');
            logger.error(err);
            process.exit(1);
        }
    });
    mfDevCommand.action(async (options)=>{
        try {
            const cliMfDev = async ()=>{
                const { config, watchFiles } = await init(options);
                await startMFDevServer(config, {
                    lib: options.lib
                });
                watchFilesForRestart(watchFiles, async ()=>{
                    await cliMfDev();
                });
            };
            await cliMfDev();
        } catch (err) {
            logger.error('Failed to start mf-dev.');
            logger.error(err);
            process.exit(1);
        }
    });
    cli.parse();
}
function initNodeEnv() {
    if (!process.env.NODE_ENV) {
        const command = process.argv[2] ?? '';
        process.env.NODE_ENV = [
            'build'
        ].includes(command) ? 'production' : 'development';
    }
}
function prepareCli() {
    initNodeEnv();
    const { npm_execpath } = process.env;
    if (!npm_execpath || npm_execpath.includes('npx-cli.js') || npm_execpath.includes('.bun')) console.log();
    logger.greet(`  Rslib v0.11.0\n`);
}
const src_version = "0.11.0";
var __webpack_exports__rspack = __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__.rspack;
export { build, defineConfig, inspect, loadConfig, logger, prepareCli, __WEBPACK_EXTERNAL_MODULE__rsbuild_core_1b356efc__ as rsbuild, runCli, startMFDevServer, composeCreateRsbuildConfig as unstable_composeCreateRsbuildConfig, src_version as version, __webpack_exports__rspack as rspack };
