import node_path, { extname } from "node:path";
const BASE_URI = 'webpack://';
const AUTO_PUBLIC_PATH = '__mini_css_extract_plugin_public_path_auto__';
const ABSOLUTE_PUBLIC_PATH = `${BASE_URI}/mini-css-extract-plugin/`;
const SINGLE_DOT_PATH_SEGMENT = '__mini_css_extract_plugin_single_dot_path_segment__';
const DTS_EXTENSIONS = [
    'd.ts',
    'd.mts',
    'd.cts'
];
const JS_EXTENSIONS = [
    'js',
    'mjs',
    'jsx',
    '(?<!\\.d\\.)ts',
    '(?<!\\.d\\.)mts',
    '(?<!\\.d\\.)cts',
    'tsx',
    'cjs',
    'cjsx',
    'mjsx',
    'mtsx',
    'ctsx'
];
const CSS_EXTENSIONS = [
    'css',
    'sass',
    'scss',
    'less',
    'styl',
    'stylus'
];
new RegExp(`\\.(${JS_EXTENSIONS.join('|')})$`);
new RegExp(`\\.(${CSS_EXTENSIONS.join('|')})$`);
new RegExp(`\\.(${DTS_EXTENSIONS.join('|')})$`);
const CSS_MODULE_REG = /\.module\.\w+$/i;
const PATH_QUERY_FRAGMENT_REGEXP = /^((?:\u200b.|[^?#\u200b])*)(\?(?:\u200b.|[^#\u200b])*)?(#.*)?$/;
function parsePathQueryFragment(str) {
    const match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);
    return {
        path: match?.[1]?.replace(/\u200b(.)/g, '$1') || '',
        query: match?.[2] ? match[2].replace(/\u200b(.)/g, '$1') : '',
        fragment: match?.[3] || ''
    };
}
function isCssModulesFile(filepath, auto) {
    const filename = node_path.basename(filepath);
    if (true === auto) return CSS_MODULE_REG.test(filename);
    if (auto instanceof RegExp) return auto.test(filepath);
    if ('function' == typeof auto) {
        const { path, query, fragment } = parsePathQueryFragment(filepath);
        return auto(path, query, fragment);
    }
    return false;
}
const LOADER_NAME = 'LIB_CSS_EXTRACT_LOADER';
function stringifyLocal(value) {
    return 'function' == typeof value ? value.toString() : JSON.stringify(value);
}
const libCssExtractLoader_loader = function(content) {
    if (this._compiler?.options?.experiments?.css && this._module && ('css' === this._module.type || 'css/auto' === this._module.type || 'css/global' === this._module.type || 'css/module' === this._module.type)) return content;
};
const pitch = function(request, _, _data) {
    if (this._compiler?.options?.experiments?.css && this._module && ('css' === this._module.type || 'css/auto' === this._module.type || 'css/global' === this._module.type || 'css/module' === this._module.type)) {
        const e = new Error("use type 'css' and `CssExtractRspackPlugin` together, please set `experiments.css` to `false` or set `{ type: \"javascript/auto\" }` for rules with `CssExtractRspackPlugin` in your rspack config (now `CssExtractRspackPlugin` does nothing).");
        e.stack = void 0;
        this.emitWarning(e);
        return;
    }
    const options = this.getOptions();
    const emit = void 0 !== options.emit ? options.emit : true;
    const callback = this.async();
    const filepath = this.resourcePath;
    const rootDir = options.rootDir ?? this.rootContext;
    const auto = options.auto;
    const banner = options.banner;
    const footer = options.footer;
    let { publicPath } = this._compilation.outputOptions;
    if ('string' == typeof options.publicPath) publicPath = options.publicPath;
    else if ('function' == typeof options.publicPath) publicPath = options.publicPath(this.resourcePath, this.rootContext);
    if ('auto' === publicPath) publicPath = AUTO_PUBLIC_PATH;
    let publicPathForExtract;
    if ('string' == typeof publicPath) {
        const isAbsolutePublicPath = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/.test(publicPath);
        publicPathForExtract = isAbsolutePublicPath ? publicPath : `${ABSOLUTE_PUBLIC_PATH}${publicPath.replace(/\./g, SINGLE_DOT_PATH_SEGMENT)}`;
    } else publicPathForExtract = publicPath;
    const handleExports = (originalExports)=>{
        let locals;
        let namedExport;
        const esModule = void 0 !== options.esModule ? options.esModule : true;
        let dependencies = [];
        try {
            const exports = originalExports.__esModule ? originalExports.default : originalExports;
            namedExport = originalExports.__esModule && (!originalExports.default || !('locals' in originalExports.default));
            if (namedExport) {
                for (const key of Object.keys(originalExports))if ('default' !== key) {
                    if (!locals) locals = {};
                    locals[key] = originalExports[key];
                }
            } else locals = exports?.locals;
            if (Array.isArray(exports) && emit) {
                const identifierCountMap = new Map();
                dependencies = exports.map(([id, content, media, sourceMap, supports, layer])=>{
                    const identifier = id;
                    const context = this.rootContext;
                    const count = identifierCountMap.get(identifier) || 0;
                    identifierCountMap.set(identifier, count + 1);
                    return {
                        identifier,
                        context,
                        content,
                        media,
                        supports,
                        layer,
                        identifierIndex: count,
                        sourceMap: sourceMap ? JSON.stringify(sourceMap) : void 0,
                        filepath
                    };
                }).filter((item)=>null !== item);
            }
        } catch (e) {
            callback(e);
            return;
        }
        const result = function() {
            if (locals) {
                if (namedExport) {
                    const identifiers = Array.from(function*() {
                        let identifierId = 0;
                        for (const key of Object.keys(locals)){
                            identifierId += 1;
                            yield [
                                `_${identifierId.toString(16)}`,
                                key
                            ];
                        }
                    }());
                    const localsString = identifiers.map(([id, key])=>`\nvar ${id} = ${stringifyLocal(locals[key])};`).join('');
                    const exportsString = `export { ${identifiers.map(([id, key])=>`${id} as ${JSON.stringify(key)}`).join(', ')} }`;
                    const defaultExport = void 0 !== options.defaultExport ? options.defaultExport : false;
                    return defaultExport ? `${localsString}\n${exportsString}\nexport default { ${identifiers.map(([id, key])=>`${JSON.stringify(key)}: ${id}`).join(', ')} }\n` : `${localsString}\n${exportsString}\n`;
                }
                return `\n${esModule ? 'export default' : 'module.exports = '} ${JSON.stringify(locals)};`;
            }
            if (esModule) return '\nexport {};';
            return '';
        }();
        let resultSource = `// extracted by ${LOADER_NAME}`;
        let importCssFiles = '';
        function getRelativePath(from, to) {
            let relativePath = node_path.relative(from, to);
            if (!relativePath.startsWith('./') && !relativePath.startsWith('../') && !node_path.isAbsolute(relativePath)) relativePath = `./${relativePath}`;
            return relativePath;
        }
        const m = new Map();
        for (const { content, filepath, sourceMap } of dependencies){
            let distFilepath = getRelativePath(rootDir, filepath);
            const ext = extname(distFilepath);
            if ('css' !== ext) distFilepath = distFilepath.replace(ext, '.css');
            if (isCssModulesFile(filepath, auto)) distFilepath = distFilepath.replace(/\.module\.css/, '_module.css');
            const cssFilename = node_path.basename(distFilepath);
            if (content.trim()) {
                m.get(distFilepath) ? m.set(distFilepath, `${m.get(distFilepath) + content}\n`) : m.set(distFilepath, `${content}\n`);
                importCssFiles += '\n';
                importCssFiles += `import "./${cssFilename}"`;
            }
            if (sourceMap) {
                const sourceMapPath = `${distFilepath}.map`;
                m.set(sourceMapPath, `${sourceMap}`);
                const sourceMappingURL = `/*# sourceMappingURL=${cssFilename}.map */`;
                m.set(distFilepath, `${m.get(distFilepath)}\n${sourceMappingURL}`);
            }
        }
        for (let [distFilepath, content] of m.entries()){
            if (banner) content = `${banner}\n${content}`;
            if (footer) content = `${content}\n${footer}\n`;
            this.emitFile(distFilepath, content);
        }
        resultSource += importCssFiles;
        resultSource += result;
        callback(null, resultSource, void 0);
    };
    this.importModule(`${this.resourcePath}.webpack[javascript/auto]!=!!!${request}`, {
        layer: options.layer,
        publicPath: publicPathForExtract,
        baseUri: `${BASE_URI}/`
    }, (error, exports)=>{
        if (error) return void callback(error);
        handleExports(exports);
    });
};
const libCssExtractLoader = libCssExtractLoader_loader;
export { libCssExtractLoader as default, pitch };
