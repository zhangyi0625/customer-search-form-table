import { logger } from "@rsbuild/core";
import picocolors from "picocolors";
import typescript from "typescript";
import { getTimeCost, processDtsFiles } from "./utils.js";
const logPrefixTsc = picocolors.dim('[tsc]');
const formatHost = {
    getCanonicalFileName: (path)=>path,
    getCurrentDirectory: typescript.sys.getCurrentDirectory,
    getNewLine: ()=>typescript.sys.newLine
};
async function handleDiagnosticsAndProcessFiles(diagnostics, configPath, bundle, declarationDir, dtsExtension, redirect, rootDir, banner, footer, name) {
    const diagnosticMessages = [];
    for (const diagnostic of diagnostics){
        const message = typescript.formatDiagnosticsWithColorAndContext([
            diagnostic
        ], formatHost);
        diagnosticMessages.push(message);
    }
    await processDtsFiles(bundle, declarationDir, dtsExtension, redirect, configPath, rootDir, banner, footer);
    if (diagnosticMessages.length) {
        for (const message of diagnosticMessages)logger.error(logPrefixTsc, message);
        const error = new Error(`Failed to generate declaration files. ${picocolors.gray(`(${name})`)}`);
        error.stack = '';
        throw error;
    }
}
async function emitDts(options, onComplete, bundle = false, isWatch = false, build = false) {
    const start = Date.now();
    const { configPath, tsConfigResult, declarationDir, name, dtsExtension, rootDir, banner, footer, redirect } = options;
    const { options: rawCompilerOptions, fileNames, projectReferences } = tsConfigResult;
    const compilerOptions = {
        ...rawCompilerOptions,
        configFilePath: configPath,
        noEmit: false,
        declaration: true,
        declarationDir,
        emitDeclarationOnly: true
    };
    const createProgram = typescript.createSemanticDiagnosticsBuilderProgram;
    const reportDiagnostic = (diagnostic)=>{
        logger.error(logPrefixTsc, typescript.formatDiagnosticsWithColorAndContext([
            diagnostic
        ], formatHost));
    };
    const reportWatchStatusChanged = async (diagnostic, _newLine, _options, errorCount)=>{
        const message = `${typescript.flattenDiagnosticMessageText(diagnostic.messageText, formatHost.getNewLine())} ${picocolors.gray(`(${name})`)}`;
        if (6031 === diagnostic.code || 6032 === diagnostic.code) logger.info(logPrefixTsc, message);
        if (6194 === diagnostic.code) {
            if (0 !== errorCount && errorCount) logger.error(logPrefixTsc, message);
            else {
                logger.info(logPrefixTsc, message);
                onComplete(true);
            }
            await processDtsFiles(bundle, declarationDir, dtsExtension, redirect, configPath, rootDir, banner, footer);
        }
        if (6193 === diagnostic.code) {
            logger.error(logPrefixTsc, message);
            await processDtsFiles(bundle, declarationDir, dtsExtension, redirect, configPath, rootDir, banner, footer);
        }
    };
    const renameDtsFile = (fileName)=>{
        if (bundle) return fileName;
        return fileName.replace(/\.d\.ts$/, dtsExtension);
    };
    const system = {
        ...typescript.sys,
        writeFile: (fileName, contents, writeByteOrderMark)=>{
            typescript.sys.writeFile(renameDtsFile(fileName), contents, writeByteOrderMark);
        }
    };
    if (isWatch) if (build) {
        const host = typescript.createSolutionBuilderWithWatchHost(system, createProgram, reportDiagnostic, void 0, reportWatchStatusChanged);
        const solutionBuilder = typescript.createSolutionBuilderWithWatch(host, [
            configPath
        ], compilerOptions, {
            watch: true
        });
        solutionBuilder.build();
    } else {
        const host = typescript.createWatchCompilerHost(configPath, compilerOptions, system, createProgram, reportDiagnostic, reportWatchStatusChanged);
        typescript.createWatchProgram(host);
    }
    else {
        if (build || compilerOptions.composite) if (!build && compilerOptions.composite) {
            const originHost = typescript.createIncrementalCompilerHost(compilerOptions);
            const host = {
                ...originHost,
                writeFile: (fileName, contents, writeByteOrderMark, onError, sourceFiles)=>{
                    originHost.writeFile(renameDtsFile(fileName), contents, writeByteOrderMark, onError, sourceFiles);
                }
            };
            const program = typescript.createIncrementalProgram({
                rootNames: fileNames,
                options: compilerOptions,
                configFileParsingDiagnostics: typescript.getConfigFileParsingDiagnostics(tsConfigResult),
                projectReferences,
                host,
                createProgram
            });
            const allDiagnostics = [];
            allDiagnostics.push(...program.getConfigFileParsingDiagnostics(), ...program.getSyntacticDiagnostics(), ...program.getOptionsDiagnostics(), ...program.getGlobalDiagnostics(), ...program.getSemanticDiagnostics(), ...program.getDeclarationDiagnostics());
            const emitResult = program.emit();
            allDiagnostics.push(...emitResult.diagnostics);
            const sortAndDeduplicateDiagnostics = typescript.sortAndDeduplicateDiagnostics(allDiagnostics);
            await handleDiagnosticsAndProcessFiles(sortAndDeduplicateDiagnostics, configPath, bundle, declarationDir, dtsExtension, redirect, rootDir, banner, footer, name);
        } else {
            let errorNumber = 0;
            const reportErrorSummary = (errorCount)=>{
                errorNumber = errorCount;
            };
            const host = typescript.createSolutionBuilderHost(system, createProgram, reportDiagnostic, void 0, reportErrorSummary);
            const solutionBuilder = typescript.createSolutionBuilder(host, [
                configPath
            ], compilerOptions);
            solutionBuilder.build();
            await processDtsFiles(bundle, declarationDir, dtsExtension, redirect, configPath, rootDir, banner, footer);
            if (errorNumber > 0) {
                const error = new Error(`Failed to generate declaration files. ${picocolors.gray(`(${name})`)}`);
                error.stack = '';
                throw error;
            }
        }
        else {
            const originHost = typescript.createCompilerHost(compilerOptions);
            const host = {
                ...originHost,
                writeFile: (fileName, contents, writeByteOrderMark, onError, sourceFiles)=>{
                    originHost.writeFile(renameDtsFile(fileName), contents, writeByteOrderMark, onError, sourceFiles);
                }
            };
            const program = typescript.createProgram({
                rootNames: fileNames,
                options: compilerOptions,
                projectReferences,
                host,
                configFileParsingDiagnostics: typescript.getConfigFileParsingDiagnostics(tsConfigResult)
            });
            const preEmitDiagnostics = typescript.getPreEmitDiagnostics(program);
            const emitResult = program.emit();
            const allDiagnostics = preEmitDiagnostics.concat(emitResult.diagnostics);
            const sortAndDeduplicateDiagnostics = typescript.sortAndDeduplicateDiagnostics(allDiagnostics);
            await handleDiagnosticsAndProcessFiles(sortAndDeduplicateDiagnostics, configPath, bundle, declarationDir, dtsExtension, redirect, rootDir, banner, footer, name);
        }
        if (bundle) logger.info(`declaration files prepared in ${getTimeCost(start)} ${picocolors.gray(`(${name})`)}`);
        else logger.ready(`declaration files generated in ${getTimeCost(start)} ${picocolors.gray(`(${name})`)}`);
    }
}
export { emitDts };
