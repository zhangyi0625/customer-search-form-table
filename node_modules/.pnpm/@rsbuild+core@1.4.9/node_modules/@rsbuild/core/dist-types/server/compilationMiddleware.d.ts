import type { IncomingMessage, ServerResponse } from 'node:http';
import type { Compiler, MultiCompiler, Stats } from '@rspack/core';
import type { DevConfig, EnvironmentContext, NextFunction, ServerConfig } from '../types';
export declare const isClientCompiler: (compiler: {
    options: {
        target?: Compiler["options"]["target"];
    };
}) => boolean;
export type ServerCallbacks = {
    onInvalid: (token: string, fileName?: string | null) => void;
    onDone: (token: string, stats: Stats) => void;
};
export declare const setupServerHooks: ({ compiler, token, callbacks: { onDone, onInvalid }, }: {
    compiler: Compiler;
    token: string;
    callbacks: ServerCallbacks;
}) => void;
type Middleware = (req: IncomingMessage, res: ServerResponse, next: NextFunction) => Promise<void>;
export type CompilationMiddlewareOptions = {
    /**
     * To ensure HMR works, the devMiddleware need inject the HMR client path into page when HMR enable.
     */
    clientPaths?: string[];
    /**
     * Should trigger when compiler hook called
     */
    callbacks: ServerCallbacks;
    devConfig: DevConfig;
    serverConfig: ServerConfig;
    environments: Record<string, EnvironmentContext>;
};
export type CompilationMiddleware = Middleware & {
    close: (callback: (err: Error | null | undefined) => void) => any;
    watch: () => void;
};
/**
 * The CompilationMiddleware handles compiler setup for development:
 * - Call `compiler.watch` (handled by rsbuild-dev-middleware)
 * - Inject the HMR client path into page
 * - Notify server when compiler hooks are triggered
 */
export declare const getCompilationMiddleware: (compiler: Compiler | MultiCompiler, options: CompilationMiddlewareOptions) => Promise<CompilationMiddleware>;
export {};
